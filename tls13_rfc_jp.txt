The Transport Layer Security (TLS) Protocol Version 1.3
draft-ietf-tls-tls13-21

私的翻訳版です。
内容については意訳、超訳、誤りが多くあると思われますので、正確性について
保証できません。
意味が日本語で表現しにくい場合などは、カタカナでごまかしている箇所が多々
あります。

========================================================================
Abstract

   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 4, 2018.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.
========================================================================

1.  Introduction

TLSの主な目的は、通信対象間とにセキュアなチャネルを提供することです。
特に、以下の特性を提供します。


 - 認証
   サーバが常に認証されているものであること。また、クライアント側は任意
   で認証を行うことができます。認証は非対称性の暗号方式(RSA,ECDSA,EdDSA)、
   またはに事前共有鍵方式(PSK)によって行われます。

 - 機密性
   チャネル間でやり取りするデータは、エンドポイントにのみ読み取ることが
   できます。TLSはデータ長を隠しませんが、TLSレコードにパディングを付与
   することができ、解析者からデータ長を隠蔽することができます。

 - 完全性
   チャネル間を流れるデータは、攻撃者によって改竄されません。


これらの特性は、攻撃者によって完全に掌握しているネットワーク下にあっても、
保持されるべきです。


TLSは2つの要素から構成されています。

 - ハンドシェイクプロトコル(Section 4)
   ハンドシェイクプロトコルは、通信者間の認証と、暗号方式のモードとパラメ
   ータの折衝、共有鍵の確立を行います。
   ハンドシェイクプロトコルは、攻撃者によって、通信者間で異なるパラメータ
   をネゴシエーションされないように、耐タンパ性を持つように設計されていま
   す。

 - レコードプロトコル(Section 5)
   レコードプロトコルは、ハンドシェイクプロトコルによって確立されたパラメ
   ータを使い、ピアとの通信を行うために利用します。
   レコードプロトコルによって、トラッフィックをレコードに分割し、それぞれ
   を通信鍵によって独立して保護します。

TLSはアプリケーションプロトコルとは独立しています。TLSの上に、上位レイヤー
のプロトコルを透過的に利用することができます。しかし、TLSの標準では、プロ
トコルに対してどのようにTLSを付与するかを指定していません。


このドキュメントはTLS version 1.3を規定します。TLS 1.3は以前のバージョンと
直接的な互換はありませんが、すべてのTLSバージョンのクライアントおよびサー
バと相互にネゴシエーションを行えるメカニズムを有しています。

このドキュメントをもって、TLS 1.2[RFC5246]を含む、以前のTLSのRFCを廃却し、
置き換えます。TLSチケット[RFC5077]もまたSection 2.2で定義するものと置き換
えられます。Section 4.2.6では[RFC4492]で規定した楕円曲線のネゴシエーション
に関する規定を更新しています。TLS 1.3が[RFC5705]のキーマテリアルの導出方法
を更新したため(Section 7.5)、これによりOCSPメッセージもまた[RFC6066]の規定
を更新し、[RFC6961]を廃却することとなります(Section 4.4.2.1)。


1.1. 用語について

ここは割愛します。


1.2. 変更履歴

 draft-21
  - 各チケットを別のPSKと関連付けるため、チケット毎のnonceを追加しました。
  - クライアントがハンドシェイク鍵を使用してアラートを送信すべき理由を明記
    しました。
  - リキーイベント時のステートマシンを更新しました。
  - 0-RTT及びリプレイについての議論を追加します。実装において、いくつかの
    耐リプレイ攻撃のメカニズムを推奨します。

 draft-20
  - ハンドシェイク後の認証を行うため、"post_handshake_auth"拡張を追加しま
    した。
  - ひとつの圧縮ブロックに収めるため、HKDF-Expand-Labelを短いラベルにしま
    した。
  - RFC7250の方法を規定します。
  - PSK時でもハンドシェイク後のクライアント認証を使えるようにします。
    (以前の"禁止"は編集のミスになります)
  - TLS 1.3では働かない、cert_typeとuser_mappingを削除しました。
  - no_application_protocolアラートを追加しました。([RFC7301]より)
  - トラフィック解析とサイドチャネル攻撃に関する議論を追加しました。

 draft-19
  - Exporters(Section 7.5)の入力で、Hash context_valueを使用します。
  - Exportersに追加のDerive-Secretを加えます。
  - HRR(HelloRetryRequest)の時に、ClientHello1のハッシュを利用します。この
    変更によりクッキーを運搬する必要がなくなります。
  - CertificateRequestを再構成し、selectorsをすべてextensionsへ入れます。
    これによりクライアントはtrusted_ca_keysに代わって"certificate_authorities"
    の拡張も定義できるようになります。
  - レコードフレームの規定を厳格にし、チェックを要求するようにします。
  - "ticket_early_data_info"と"early_data"を統合し、ひとつの拡張にまとめま
    す。
  - end_of_early_dataをハンドシェイクメッセージに変更します。
  - キースケジュール(Section 7.1)に事前に展開するDerive-Scretを追加します。
  - "pre_shared_key"の実装の擬似要求を削除しました。
  - サーバからの"early_data"のロケーションを明記します。
  - ピアの公開鍵の検証を必須にします。
  - ステートマシン図を追加しました。

 draft-18
  - セッション再開時の、不要なresumption_pskを削除しました。 
  - Extensionの表中のsignature_algorithmsを修正しました。
  - ハンドシェイクのレジューム時、SNIが同じでないと、レジュームできないこと
    を[RFC6066]より、再度定義しました。

 draft-17
  - 0-RTT Finishとresumption_contextを削除し、PSK自身のpsk_binderフィールド
    に置き換えました。
  - PSK鍵交換のネゴシエーションを再構成しました。
  - TicketEarlyDataInfoにmax_early_data_sizeフィールドを追加しました。
  - 0-RTT のexporterを追加し、通常ハンドシェイクのexporterを変更しました。
  - TicketExtensionsをExtensionsにマージし、ticket_early_data_infoのコードポ
    イントを変更しました。
  - Client.key_sharesをHRRに置き換えました。
  - 転送鍵の導出から、余計なラベルを削除しました。

 draft-16
 - バージョンのネゴシエーションを修正しました。
 - RSASSA-PSSとEdDsaのSignatureSchemeのコードポイントを後方互換性を考慮したも
   のに変更しました。
 - HelloRetryRequest.selected_groupを拡張へ移動しました。
 - exporter contextがない場合の振る舞いを、空のcontextと同じであることを明記
   しました。
 - KeyUpdataのフォーマットを新しくし、キースケジュールとは独立して更新できる
   ように変更を行いました。
 - certificate_requiredアラートを新規に設定しました。
 - 0-RTTとPSK時のCertificateRequestを禁止しました。
 - 0-RTT時のSNIのチェックを緩和しました。

 draft-15
 - ベルリンで議論された、新しいネゴシエーション記法で記述しました。
 - ハンドシェイク中はCertificateRequest.contextは空であることを要求するように
   します。
 - 空のチケットを禁止します。
 - ネゴシエーション間で同じ暗号セットでのアプリケーションデータのメッセージを
   禁止します。
 - アラートのガイダンスを整理しました。
 - TLS 1.2の必要性を整理しました。
 - 0-RTTのタイムウィンドウのガイダンスを記載しました。
 - 古いPRNG(擬似乱数生成)に関する記述を削除しました。
 - 鍵の変更にまたがったハンドシェイクレコードのチェックを明示的に要求するよう
   にしました。
 
 draft-14
書きかけ

 draft-13

 draft-12

 draft-11

 draft-10

 draft-9

 draft-8

 draft-7

 draft-6

 draft-5

 draft-4

 draft-3

 draft-2


1.3. TLS 1.2からの主な変更点
下記にTLS 1.2とTLS 1.3の主な機能の違いを記述します。しかし、これは差異を網羅
しておらず、多くの小さな変更が存在します。

 - 対称暗号のアルゴリズムは、すでにレガシーであると考えられるため、未サポート
   としています。そのため、ADAD(認証付き暗号)のアルゴリズムのみが利用可能です。
   暗号スイートは、認証・鍵交換のメカニズムと、レコードの保護とを分離するよう
   に構想が変化しています。そして、ハッシュは鍵導出とHMACとして使われます。

 - Zero-RTTモードが追加され、セキュアにアプリケーションデータをやり取りするま
   でのラウンドトリップを短縮します。

 - 静的なRSAおよびDiffie-Helmanの暗号スイートを削除します。すべての公開鍵は鍵
   交換メカニズムで即時生成し、Forward secrecyを提供します。

 - ServerHelloより後の、すべてのハンドシェイクメッセージを暗号化します。新しく
   EncryptedExtensionを導入します。EncryptedExtensionはServerHelloの様々な
   extensionsより先に送信することができ、機密性の高い保護が可能です。

 - 鍵の導出関数について再設計されました。新しい設計では、鍵の特性を分離し、改
   善したことで、暗号技術者による解析が容易になりました。
   HMAC-based Extract-and-Expand Key Derivation Function(HKDF)は原始性を基底と
   して使用されています。

 - ハンドシェイクのステートマシンを大幅に再構成しました。またChangeCipherSpec
   などの無駄なメッセージを削除しています。

 - ed25519やed448などのECCは、基本構成として新しいsignature algorithmsに組み入
   れられています。TLS 1.3では、座標のフォーマットのネゴシエーションはなくなり
   単一のフォーマットになります。

 - その他の暗号周りの改善を行っています。これには、圧縮やカスタムDHEグループ、
   PSSへのRSAパディングの変更、DSAの削除を含んでいます。

 - version list拡張によって、TLS 1.2でネゴシエーションする方式はあまり推奨され
   ません。これは、サーバ側が選択するバージョンの実装の互換性の問題を増加させ
   ます。

 - サーバ側が古いTLSバージョンのPSKベースの暗号スイートを利用する、しないに関
   わらず、セッションの再開では、新しいPSK方式に置き換えます。

 - 参照するRFCを適切なものに更新します。


1.4. TLS 1.2に影響する更新
このドキュメントはTLS 1.2の実装に影響するいくつかの変更を定義しています。

 - バージョンダウングレード保護機構をSection 4.1.3に記載しています。

 - RSASSA-PSSをSection 4.2.3に規定しています。

 - "supported_version"のClientHello拡張をレガシーバージョンのlientHelloより優
   先して利用できるようにします。

TLS 1.3の実装において、TLS 1.2の変更のサポートもまた必要かもしれません。各セク
ションで詳細を参照してください。



2. プロトコル概要
セキュアチャネルで利用される暗号パラメータは、TLSハンドシェイクプロトコルによっ
て提供されます。このTLSのサブプロトコルは、最初の通信時、クライアントとサーバに
よって利用されます。ハンドシェイクプロトコルは、ピア間のプロトコルバージョンの
ネゴシエーション、暗号アルゴリズムの選択、任意での互いの認証、そしてキーマテリ
アルの共有を行います。一度ハンドシェイクが完了すると、ピア同士は確立した鍵を利
用してアプリケーションレイヤーのトラフィックを保護します。

ハンドシェイクや他のプロトコルエラーが発生した場合、任意でエラーアラートを送信
して、接続を終了します。(Section 6)

TLSは3つの基本的な鍵交換方式をサポートします。

 - (EC)DHE (有限体または楕円曲線のDiffie-Hellman)
 - PSK-only
 - PSK with (EC)DHE

図1にTLSフルハンドシェイクを示します。


       Client                                               Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*         -------->
                                                       ServerHello  ^ Key
                                                      + key_share*  | Exch
                                                 + pre_shared_key*  v
                                             {EncryptedExtensions}  ^  Server
                                             {CertificateRequest*}  v  Params
                                                    {Certificate*}  ^
                                              {CertificateVerify*}  | Auth
                                                        {Finished}  v
                                 <--------     [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}                -------->
       [Application Data]        <------->      [Application Data]

              +  前に書かれたメッセージの拡張として送信することを表し
                 ます。

              *  任意、または状況に応じてメッセージ/拡張を送信すること
                 を表します。必ず送信するものではありません。

              {} [sender]_handshake_traffic_secretによって暗号化された
                 メッセージを表します。

              [] [sender]_application_traffic_secret_Nによって暗号化さ
                 メッセージを表します。

               図 1: TLSフルハンドシェイクメッセージ


ハンドシェイクは上記図の3つのフェーズからなります。

 - 鍵交換
   キーマテリアルの共有と暗号パラメータを決定します。このフェーズ以降、
   すべてのメッセージは暗号化されます。

 - サーバパラメータ
   クライアント認証やアプリケーションレイヤープロトコルなど、他のハン
   ドシェイクパラメータを決定します。

 - 認証
   サーバの認証、および任意でクライアントの認証と、鍵とハンドシェイク
   の整合性の確認を行います。

鍵交換のフェーズでは、クライアントはランダムのnonce(ClientHello.random)
を含めたClientHelloメッセージ(Section 4.1.2)を送信します。これは、プロ
トコルバージョン、暗号/HKDFハッシュのリスト、Diffie-Hellman鍵共有
(Section 4.2.7の"key_share"拡張を参照)、事前共有鍵のラベル(Section 4.2.10
の"pre_shared_key"の設定、追加の拡張情報などを通知します。

サーバは、ClientHelloにより適切な暗号パラメータを決定します。その際に
ネゴシエーションする接続パラメータをServerHello(Section 4.1.3)にて応答し
ます。ClientHelloとServerHelloにより共有鍵を決定します。(EC)DHE鍵が利用さ
れる場合、サーバはServerHelloの"key_share"拡張に、クライアントが通知した
グループと同じグループの一時Diffie-Hellman鍵を含めなければなりません[MUST]。
PSKが利用される場合、サーバはServerHelloの"pre_shared_key"拡張でクライア
ントが要求したPSKが選択されたかを通知します。実装は両方の拡張が通知された
場合、(EC)DHEとPSKを同時に使うことができます。

サーバは自身のパラメータの確立のため、2つのメッセージを送信します。

 EncryptedExtensions
 証明書以外に暗号パラメータを決定する必要がないClientHello拡張に応答 しま
 す。
 [Section 4.3.1]

 CertificateRequest
 証明書を利用したクライアント認証が必要な場合、CertificateRequestによって
 要求するパラメータを通知します。このメッセージはクライアント認証が不要な
 場合は必要ありません。
 [Section 4.3.2]

最後にクライアントとサーバは認証メッセージを交換します。TLSは認証が必要な
時は毎回、同じメッセージのセットを利用します。

 Certificate
 エンドポイントの証明書と、すべての証明書の拡張に利用されます。このメッセ
 ージは、証明書による認証が不要な場合はサーバによって、CertificateRequest
 メッセージがない場合はクライアントによって不要とされ、利用されません。
 もし生の公開鍵[RFC7250]やキャッシュ情報の拡張[RFC7924]が利用された場合、
 このメッセージは証明書ではなく、サーバの長期の鍵と一致する値とが含まれま
 す。
 [Section 4.4.2]

 CertificateVerify
 ハンドシェイク全体のシグネチャを証明書の秘密鍵で暗号化したメッセージです。
 このメッセージは、エンドポイントが証明書による認証を不要とした場合は、必
 要ありません
 [Section 4.4.3]

 Finished
 ハンドシェイク全体のMAC(Message Authentication Code)です。このメッセージ
 はエンドポイントの鍵交換によって生成された鍵の確認に利用します。PSKの場
 合はさらにハンドシェイクの認証にも利用します。
 [Section 4.4.4]

上記のサーバのメッセージを受信した場合、クライアントはCertificate、
CertificateVerify、Finishに応じた、クライアント側の認証メッセージを送信し
ます。

これらのメッセージのポイントは、クライアントとサーバは認証された暗号を通し
て、アプリケーションデータを保護するレコードレイヤーのキーマテリアルを導出
し、ハンドシェイクを完了させなければならないことです。アプリケーションデー
タはFinishメッセージよりも前に暗号化されたレコードレイヤーを送信してないけ
ません[MUST NOT]。
サーバは、クライアントの認証メッセージを受ける前にレコードレイヤーを送信し
ますが、その時は認証されてないピアに送信することとなります。


2.1. DHE鍵共有の不一致について
もし、クライアントが適当な"key_share"拡張を提供しない場合(つまり、サーバが
受け付けないDHEまたはECDHEのグループしか送信しない場合)、サーバは図2で示す
ように、HelloRetryRequestにより不一致を通知し、クライアントは適切な
"key_share"拡張により再度ハンドシェイクを行う必要があります。もし共通する暗
号パラメータがない場合、サーバは適切なアラートによりハンドシェイクを破棄
しなければなりません[MUST]。


            Client                                               Server

            ClientHello
            + key_share             -------->
                                    <--------         HelloRetryRequest
                                                            + key_share

            ClientHello
            + key_share             -------->
                                                            ServerHello
                                                            + key_share
                                                  {EncryptedExtensions}
                                                  {CertificateRequest*}
                                                         {Certificate*}
                                                   {CertificateVerify*}
                                                             {Finished}
                                    <--------       [Application Data*]
            {Certificate*}
            {CertificateVerify*}
            {Finished}              -------->
            [Application Data]      <------->        [Application Data]

                    図2: フルハンドシェイク時のパラメータの不一致

注意:初回のClientHello/HelloRetryRequestを含む、ハンドシェイクの転写は新規の
ClientHelloをリセットしません。

以降のセクションに記載しますが、TLSは基本のハンドシェイクに、いくつかの
最適化のための変形を行うことができます。


2.2. セッションの再開と、事前鍵共有(PSK)
TLSのPSKは、通信の外でも確立することができますが、以前の通信や、セッショ
ンの再利用("session resumption")でも確立することができます。一度ハンドシ
ェイクが完了すると、サーバはクライアントに、初回ハンドシェイクによって導
出したユニークキーであるPSK IDを送信することができます。
クライアントは以降のハンドシェイクにPSK IDを利用することができます。もし
サーバがPSK IDを受け付けた場合、新しいコネクションのセキュリティコンテキ
ストは、オリジナルのコネクションに紐付いた暗号と、初回のハンドシェイクと
同じキー導出により、フルハンドシェイクに代わり自力で暗号状態を確立します。
TLS 1.2やその前では、この機能は"session IDs"や"session tickets"[RFC5077]
によって提供されていました。この2つのメカニズムはTLS 1.3では廃止されてい
ます。

PSKは、(EC)DHE鍵交換を利用したforward secrecyで共有されるものや、または
forward secrecy性は喪失するが、単体で発行できるアプリケーションデータによ
って共有されるものがあります。

図3は、PSKを通知する初回のネゴシエーションと、PSKを利用した2回目のネゴシ
エーションを示します。


          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               -------->
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                -------->
                                    <--------      [NewSessionTicket]
          [Application Data]        <------->      [Application Data]


   Subsequent Handshake:
          ClientHello
          + key_share*
          + psk_key_exchange_modes
          + pre_shared_key          -------->
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Finished}                -------->
          [Application Data]        <------->      [Application Data]

                    図3: セッションレジュームとPSKのメッセージ

サーバは、PSKによる認証が行われる場合、CertificateまたはCertificateVerify
メッセージを送信しません。クライアントがPSKによるセッションのレジュームを
要求するときは、必要であればクライアントはサーバがレジュームかフルハンド
シェイクかを選択できるように"key_share"拡張を提供すべきです。サーバは、
"pre_shared_key"拡張をつけて、PSKのネゴシエーションの応答することも、
"key_share"拡張によりforward secrecyによる(EC)DHEでネゴシエーションするこ
ともできます。

PSKが通信の外で提供されている場合、PSK IDとKDFハッシュアルゴリズムもまた
通信の外で提供されたものをPSKで利用しなければなりません[MUST]。
注意: 通信外で提供された事前共有鍵を使う時は、[RFC4086]で述べられているよ
うに、エントロピー的に十分な鍵を生成するようによく考慮するべきです。共有
したパスワードや、他の低い情報量のソースから共有シークレットを導出するこ
とはセキュアではありません。パスワードや低い情報量によるシークレットでは
PSKに基づいた、辞書攻撃の対象となりえます。PSK認証は、Diffie-Hellman鍵交
換を行っていたとしても、パスワード認証による鍵の認証が決して強固なもので
はありません。


2.3. Zero-RTTデータ
クライアントとサーバが(外部または前のハンドシェイクによって得られた)PSK
を共有している時、TLS 1.3はクライアントの初回送信("early data")でデータ
を送ることができます。クライアントは、サーバの認証と、early dataの暗号化
のためにPSKを利用します。

クライアントが外部から得たPSKをearly dataの送信に利用する時は、以下の追
加情報を提供しなければなりません[MUST]。

 - PSKで利用するTLSのバージョン
 - PSKで利用する暗号スイート
 - 利用する場合は、Application-Layer Protocol Negotiation(ALPN)[RFC7301]。
 - 利用する場合は、Server Name Indication(SNI)。

図4に示すように、0-RTTデータは初回送信時に1-RTT時のハンドシェイクデータを
追加したものです。その後のハンドシェイクはPSKレジュームによる1-RTTハンド
シェイクと同様です。


            Client                                               Server

            ClientHello
            + early_data
            + key_share*
            + psk_key_exchange_modes
            + pre_shared_key
            (Application Data*)     -------->
                                                            ServerHello
                                                       + pre_shared_key
                                                           + key_share*
                                                  {EncryptedExtensions}
                                                          + early_data*
                                                             {Finished}
                                    <--------       [Application Data*]
            (EndOfEarlyData)
            {Finished}              -------->

            [Application Data]      <------->        [Application Data]

                  +  前に書かれたメッセージの拡張として送信することを表し
                     ます。

                  *  任意、または状況に応じてメッセージ/拡張を送信すること
                     を表します。必ず送信するものではありません。

                  () client_early_traffic_secretによって導出された鍵によっ
                     て暗号化されたメッセージを表します。

                  {} [sender]_handshake_traffic_secretによって暗号化された
                     メッセージを表します。

                  [] [sender]_application_traffic_secret_Nによって暗号化さ
                     メッセージを表します。

                       図4: 0ラウンドトリップハンドシェイク

重要な注意:0-RTTデータは他のTLSのデータよりもセキュリティ特性が弱いです。
           具体的には、下記のことに注意してください。

 1. このデータはPSKによって導出された鍵で暗号化しているだけのため、forward
    secret特性を持っていません。
 2. コネクション間で再利用されないことは保証されていません。本来のTLS 1.3
    の1-RTTデータはサーバランダム値によって、リプレイ攻撃への耐性を持って
    いますが、0-RTTデータはServerHelloに依存しないためです。これは、クライ
    アント認証や、アプリケーションプロトコルのデータに特に関連します。同じ
    ことがearly_exporter_master_secretにも言えます。

0-RTTデータはコネクション内で複製できません(つまりサーバは同じコネクション
上での同一データを2度は受け付けません)。また攻撃者は1-RTTデータに0-RTTのデ
ータを利用することはできません(別の鍵によって暗号化するため)。Appendix E.5
に攻撃の可能性についての記述と、Section 8にリプライ攻撃に対抗するための上限
を設けることについて記述しています。



3. 記法について
このドキュメントのデータ記法は、非常に基本的かつお馴染みの文法が利用されて
います。


3.1. ベースのブロックサイズ
すべてのデータは明確に指定されて表現されています。ベースとなるブロックサイ
ズは1バイト(つまり8bit)です。複数バイトのものは、左から右、上から下へのバイ
トの連結として表現されます。マルチバイトのバイトストリームは次のように記述
されます。

    value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
            ... | byte[n-1];

このマルチバイト値のバイトオーダはネットワークバイトオーダまたはビッグエン
ディアンです。


3.2. その他
コメントは"/*"と"*/"に囲まれています。

任意の構成要素は、"[[ ]]"内に書かれます。

バイトの集合のような、他に解釈できないようなデータはopaqueとして表現します。


3.3. ベクトル
ベクトル(一次元配列)は、同質の要素のストリームです。ベクトルのサイズは、ド
キュメントの記載時か実行時に指定されます。どちらのケースでも、ベクトルは要
素数ではなく、バイト数で長さが定義されます。
固定長のベクトルTをタイプにもった、新しく定義するベクトルのタイプをT'とする
場合、以下の表記となります。

    T T'[n];

ここでは、T'はTの倍数のサイズ分であるnバイト分のデータストリームです。

次の例では、Datumは3つの連続したバイトの定義です。Dataは3つのDatumによって
構成される、合計9バイトの構造です。

    opaque Datum[3];
    Datum Data[9];

可変長のベクトルは特定の部分を指定した、<floor..ceiling>の表記で定義されま
す。これらでエンコードされた時、実際の長さはバイトストリームのベクトルの内
容より優先されます。必要以上の長さのデータがあった場合、最大サイズまでで留
めておきます。可変長データのベクトルの実際のフィールドが0であった場合、空の
ベクトルとして扱います。

    T T'<floor..ceiling>;

次の例の1つ目のmandatoryは、長さが300〜400バイトが必須のopaqueタイプのベク
トルです。これは空となることがありません。実際の長さのフィールドは2バイトの
Uint16で、400が上限になります(Section 3.4参照)。同じように、2つ目のlongerは
上限が800バイトで、uint16のため400個の要素が上限で、空となる場合もあります。
このエンコードの2バイトの長さのフィールドはベクトルの要素よりも前に置かれま
す。ベクトルの長さは1つの要素の倍数とならなければなりません。(つまり、uint16
のベクトルで長さが17バイトとなるのは異常とみなされます)

    opaque mandatory<300..400>;
        /* 長さのフィールドは2バイトで、空になることはありません */
    uint16 longer<0..800>;
        /* 0から400の16bitの符号なし整数です */


3.4. 数値型
基本の数値型のデータは符号なしバイト(uint8)です。より大きな数値型のデータは
Section 3.1で記述したように、バイト(uint8)が固定長連結することで形成されま
す。次のナンバータイプは事前定義されています。

    uint8 uint16[2];
    uint8 uint24[3];
    uint8 uint32[4];
    uint8 uint64[8];

すべての値は、ここか他の場所で定義されます。また、ネットワークバイトオーダ
(big-endian)で格納されます。;uint32の値を16進で表される、01 02 03 04の値は
10進の16909060の値になります。


3.5. 列挙型
値に弱い関連付けがされているデータのタイプをenumと呼びます。各定義は別のタ
イプです。同じタイプの列挙型のみを関連、比較する対象とすることができます。
すべての列挙型の要素は、以下の例のように値と関連付けられています。列挙型の
要素の順序に意味はないため、どのような順番でもユニークな値を関連付けること
ができます。

    enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;

プロトコルの拡張や追加のため、新しい値が定義されていきます。実装ではパース
した際に、フィールドの状態が違っていない限り、未知の値を無視する必要があり
ます。

列挙型では、最大値の定義に合わせたサイズのバイトストリームを専有します。次
の定義では、Colorタイプとして1バイトのフィールドを定義しています。

    enum { red(3), blue(5), white(7) } Color;

これは、余分な要素もなく、強制的にタグと関連付けられていないものの例です。

次のTasteの例では、2バイトのデータですが、値は現状は1,2,4しか定義されてい
ません。

    enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

列挙型の要素の名前は、スコープ内に定義されたタイプになります。最初の例の
2番めの要素を完全修飾形式で書く場合 Color.blue のようになります。対象が
特定できる場合は、このような書き方は不要になります。

    Color color = Color.blue;    /* 過剰な記述方式ですが、問題ありません */
    Color color = blue;          /* 正しい記述方式です。タイプは暗黙的です */

名前への関連付けは、ユニークである必要はありません。列挙の値は2つのピリオ
ドを間に入れた書き方で、範囲で同じ名前を適用することができます。これは、
スペースを予約しておく上で、非常に便利な方法です。

    enum { sad(0), meh(1..254), happy(255) } Mood;


3.6. 構造体
構成を簡易に書くため、基本型から構成される構造体を利用できます。各宣言は、
ユニークなものになります。記法は、C言語のように定義します。

    struct {
        T1 f1;
        T2 f2;
        ...
        Tn fn;
    } [[T]];

構造体のフィールドは、列挙型と同じように、タイプ名を利用した修飾子になり
ます。例えば、T.f2は上で書かれた宣言の2番目の要素への参照となります。構
造体は他の構造体に埋め込まれて定義されることがあります。どの構造体も他で
定義されているものになります。


3.7. 定数
固定値に関連付けられるものは、"="を使って、以下のように記述されます。

    struct {
        T1 f1 = 8;   /* T.f1 は必ず8である必要があります */
        T2 f2;
    } T;


3.8. 可変構造
実際の動作時に得られる値を元にして、解釈する構造を変更させる定義を行う
ことができます。selectorは、構造体の定義で取りうる範囲の変数でなければ
なりません。可変構造の決定因子はラベルの参照によって記述されます。この
ような実行時の変数によって選択される構造は、表現時の記法の段階では決定
されていません。

 struct {
     T1 f1;
     T2 f2;
     ....
     Tn fn;
     select (E) {
         case e1: Te1;
         case e2: Te2;
         ....
         case en: Ten;
     } [[fv]];
 } [[Tv]];

例:

    enum { apple(0), orange(1) } VariantTag;

    struct {
        uint16 number;
        opaque string<0..10>; /* variable length */
    } V1;

    struct {
        uint32 number;
        opaque string[10];    /* fixed length */
    } V2;

    struct {
        VariantTag type;
        select (VariantRecord.type) {
            case apple:  V1;
            case orange: V2;
        };
    } VariantRecord;


...続く

