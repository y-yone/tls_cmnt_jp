The Transport Layer Security (TLS) Protocol Version 1.3
draft-ietf-tls-tls13-21

私的翻訳版です。
内容については意訳、超訳、誤りが多くあると思われますので、正確性につい
て保証できません。
意味が日本語で表現しにくい場合などは、カタカナでごまかしている箇所が多
々あります。

========================================================================
Abstract

   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 4, 2018.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.
========================================================================

1.  Introduction

TLSの主な目的は、通信対象間とにセキュアなチャネルを提供することです。
特に、以下の特性を提供します。


 - 認証
   サーバが常に認証されているものであること。また、クライアント側は任
   意で認証を行うことができます。認証は非対称性の暗号方式(RSA,ECDSA,
   EdDSA)、またはに事前共有鍵方式(PSK)によって行われます。

 - 機密性
   チャネル間でやり取りするデータは、エンドポイントにのみ読み取ること
   ができます。TLSはデータ長を隠しませんが、TLSレコードにパディングを
   付与することができ、解析者からデータ長を隠蔽することができます。

 - 完全性
   チャネル間を流れるデータは、攻撃者によって改竄されません。


これらの特性は、攻撃者によって完全に掌握しているネットワーク下にあって
も、保持されるべきです。


TLSは2つの要素から構成されています。

 - ハンドシェイクプロトコル(Section 4)
   ハンドシェイクプロトコルは、通信者間の認証と、暗号方式のモードとパ
   ラメータの折衝、共有鍵の確立を行います。
   ハンドシェイクプロトコルは、攻撃者によって、通信者間で異なるパラメ
   ータをネゴシエーションされないように、耐タンパ性を持つように設計さ
   れています。

 - レコードプロトコル(Section 5)
   レコードプロトコルは、ハンドシェイクプロトコルによって確立されたパ
   ラメータを使い、ピアとの通信を行うために利用します。
   レコードプロトコルによって、トラッフィックをレコードに分割し、それ
   ぞれを通信鍵によって独立して保護します。

TLSはアプリケーションプロトコルとは独立しています。TLSの上に、上位レイ
ヤーのプロトコルを透過的に利用することができます。しかし、TLSの標準で
は、プロトコルに対してどのようにTLSを付与するかを指定していません。


このドキュメントはTLS version 1.3を規定します。TLS 1.3は前のバージョン
と直接的な互換はありませんが、すべてのTLSバージョンのクライアントおよ
びサーバと相互にネゴシエーションを行えるメカニズムを有しています。

このドキュメントをもって、TLS 1.2[RFC5246]を含む、以前のTLSのRFCを廃却
し、置き換えます。TLSチケット[RFC5077]もまたSection 2.2で定義するもの
と置き換えられます。Section 4.2.6では[RFC4492]で規定した楕円曲線のネゴ
シエーションに関する規定を更新しています。TLS 1.3が[RFC5705]のキーマテ
リアルの導出方法を更新したため(Section 7.5)、これによりOCSPメッセージ
もまた[RFC6066]の規定を更新し、[RFC6961]を廃却することとなります
(Section 4.4.2.1)。


1.1. 用語について

ここは割愛します。


1.2. 変更履歴

 draft-21
  - 各チケットを別のPSKと関連付けるため、チケット毎のnonceを追加しまし
    た。
  - クライアントがハンドシェイク鍵を使用してアラートを送信すべき理由を
    明記しました。
  - リキーイベント時のステートマシンを更新しました。
  - 0-RTT及びリプレイについての議論を追加します。実装において、いくつ
    かの耐リプレイ攻撃のメカニズムを推奨します。

 draft-20
  - ハンドシェイク後の認証を行うため、"post_handshake_auth"拡張を追加
    しました。
  - ひとつの圧縮ブロックに収めるため、HKDF-Expand-Labelを短いラベルに
    しました。
  - RFC7250の方法を規定します。
  - PSK時でもハンドシェイク後のクライアント認証を使えるようにします。
    (以前の"禁止"は編集のミスになります)
  - TLS 1.3では働かない、cert_typeとuser_mappingを削除しました。
  - no_application_protocolアラートを追加しました。([RFC7301]より)
  - トラフィック解析とサイドチャネル攻撃に関する議論を追加しました。

 draft-19
  - Exporters(Section 7.5)の入力で、Hash context_valueを使用します。
  - Exportersに追加のDerive-Secretを加えます。
  - HRR(HelloRetryRequest)の時に、ClientHello1のハッシュを利用します。
    この変更によりクッキーを運搬する必要がなくなります。
  - CertificateRequestを再構成し、selectorsをすべてextensionsへ入れま
    す。これによりクライアントはtrusted_ca_keysに代わって"certificate_authorities"
    の拡張も定義できるようになります。
  - レコードフレームの規定を厳格にし、チェックを要求するようにします。
  - "ticket_early_data_info"と"early_data"を統合し、ひとつの拡張にまと
    めます。
  - end_of_early_dataをハンドシェイクメッセージに変更します。
  - キースケジュール(Section 7.1)に事前に展開するDerive-Scretを追加し
    ます。
  - "pre_shared_key"の実装の擬似要求を削除しました。
  - サーバからの"early_data"のロケーションを明記します。
  - ピアの公開鍵の検証を必須にします。
  - ステートマシン図を追加しました。

 draft-18
  - セッション再開時の、不要なresumption_pskを削除しました。 
  - Extensionの表中のsignature_algorithmsを修正しました。
  - ハンドシェイクのレジューム時、SNIが同じでないと、レジュームできな
    いことを[RFC6066]より、再度定義しました。

 draft-17
  - 0-RTT Finishとresumption_contextを削除し、PSK自身のpsk_binderフィ
    ールドに置き換えました。
  - PSK鍵交換のネゴシエーションを再構成しました。
  - TicketEarlyDataInfoにmax_early_data_sizeフィールドを追加しました。
  - 0-RTT のexporterを追加し、通常ハンドシェイクのexporterを変更しまし
    た。
  - TicketExtensionsをExtensionsにマージし、ticket_early_data_infoのコ
    ードポイントを変更しました。
  - Client.key_sharesをHRRに置き換えました。
  - 転送鍵の導出から、余計なラベルを削除しました。

 draft-16
 - バージョンのネゴシエーションを修正しました。
 - RSASSA-PSSとEdDsaのSignatureSchemeのコードポイントを後方互換性を考
   慮したものに変更しました。
 - HelloRetryRequest.selected_groupを拡張へ移動しました。
 - exporter contextがない場合の振る舞いを、空のcontextと同じであること
   を明記しました。
 - KeyUpdataのフォーマットを新しくし、キースケジュールとは独立して更新
   できるように変更を行いました。
 - certificate_requiredアラートを新規に設定しました。
 - 0-RTTとPSK時のCertificateRequestを禁止しました。
 - 0-RTT時のSNIのチェックを緩和しました。

 draft-15
 - ベルリンで議論された、新しいネゴシエーション記法で記述しました。
 - ハンドシェイク中はCertificateRequest.contextは空であることを要求す
   るようにします。
 - 空のチケットを禁止します。
 - ネゴシエーション間で同じ暗号セットでのアプリケーションデータのメッ
   セージを禁止します。
 - アラートのガイダンスを整理しました。
 - TLS 1.2の必要性を整理しました。
 - 0-RTTのタイムウィンドウのガイダンスを記載しました。
 - 古いPRNG(擬似乱数生成)に関する記述を削除しました。
 - 鍵の変更にまたがったハンドシェイクレコードのチェックを明示的に要求
   するようにしました。
 
 draft-14
書きかけ

 draft-13

 draft-12

 draft-11

 draft-10

 draft-9

 draft-8

 draft-7

 draft-6

 draft-5

 draft-4

 draft-3

 draft-2


1.3. TLS 1.2からの主な変更点
下記にTLS 1.2とTLS 1.3の主な機能の違いを記述します。しかし、これは差異
を網羅しておらず、多くの細かい変更が存在します。

 - 対称暗号のアルゴリズムは、すでにレガシーであると考えられるため、未
   サポートとしています。そのため、AEAD(認証付き暗号)のアルゴリズムの
   みが利用可能です。暗号スイートは、認証・鍵交換のメカニズムと、レコ
   ードの保護とを分離し、ハッシュは鍵導出とHMACに利用するように構想が
   変化しています。

 - Zero-RTTモードが追加され、セキュアにアプリケーションデータをやり取
   りするまでのラウンドトリップを短縮します。

 - 静的なRSAおよびDiffie-Hellmanの暗号スイートを削除します。すべての公
   開鍵は鍵交換メカニズムで即時生成し、Forward secrecyを提供します。

 - ServerHelloより後の、すべてのハンドシェイクメッセージを暗号化します。
   新しくEncryptedExtensionを導入します。EncryptedExtensionはServerHello
   の様々なextensionsより先に送信することができ、機密性の高い保護が可
   能です。

 - 鍵の導出関数について再設計されました。新しい設計では、鍵の特性を分
   離し、改善したことで、暗号技術者による解析が容易になりました。
   HMAC-based Extract-and-Expand Key Derivation Function(HKDF)は原子性
   を基底として使用されています。

 - ハンドシェイクのステートマシンを大幅に再構成し、ChangeCipherSpecな
   どの無駄なメッセージを削除しています。

 - ed25519やed448などのECCは、基本構成として新しいsignature algorithms
   に組み入れられています。TLS 1.3では、座標のフォーマットのネゴシエー
   ションはなくなり単一のフォーマットになります。

 - その他の暗号周りの改善を行っています。これには、圧縮やカスタムDHEグ
   ループ、PSSへのRSAパディングの変更、DSAの削除を含んでいます。

 - version list拡張によって、TLS 1.2でネゴシエーションする方式はあまり
   推奨されません。これは、サーバ側が選択するバージョンの実装の互換性
   の問題を増加させます。

 - サーバ側が古いTLSバージョンのPSKベースの暗号スイートを利用する、し
   ないに関わらず、セッションの再開では、新しいPSK方式に置き換えます。

 - 参照するRFCを適切なものに更新します。


1.4. TLS 1.2に影響する更新
このドキュメントはTLS 1.2の実装に影響するいくつかの変更を定義していま
す。

 - バージョンダウングレード保護機構をSection 4.1.3に記載しています。

 - RSASSA-PSSをSection 4.2.3に規定しています。

 - "supported_version"のClientHello拡張をレガシーバージョンのClientHello
   より優先して利用できるようにします。

TLS 1.3の実装において、TLS 1.2の変更もまた必要かもしれません。各セクショ
ンで詳細を参照してください。



2. プロトコル概要
セキュアチャネルで利用される暗号パラメータは、TLSハンドシェイクプロト
コルによって提供されます。このTLSのサブプロトコルは、最初の通信時、ク
ライアントとサーバによって利用されます。ハンドシェイクプロトコルは、ピ
ア間のプロトコルバージョンのネゴシエーション、暗号アルゴリズムの選択、
任意での互いの認証、そしてキーマテリアルの共有を行います。一度ハンドシェ
イクが完了すると、ピア同士は確立した鍵を利用してアプリケーションレイヤ
ーのトラフィックを保護します。ハンドシェイクや他のプロトコルエラーが発
生した場合、任意でエラーアラートを送信して、接続を終了します。(Section 6)

TLSは3つの基本的な鍵交換方式をサポートします。

 - (EC)DHE (有限体または楕円曲線のDiffie-Hellman)
 - PSK-only
 - PSK with (EC)DHE

図1にTLSフルハンドシェイクを示します。


       Client                                               Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*         -------->
                                                       ServerHello  ^ Key
                                                      + key_share*  | Exch
                                                 + pre_shared_key*  v
                                             {EncryptedExtensions}  ^  Server
                                             {CertificateRequest*}  v  Params
                                                    {Certificate*}  ^
                                              {CertificateVerify*}  | Auth
                                                        {Finished}  v
                                 <--------     [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}                -------->
       [Application Data]        <------->      [Application Data]

              +  前に書かれたメッセージの拡張として送信することを表し
                 ます。

              *  任意、または状況に応じてメッセージ/拡張を送信すること
                 を表します。必ず送信するものではありません。

              {} [sender]_handshake_traffic_secretによって暗号化された
                 メッセージを表します。

              [] [sender]_application_traffic_secret_Nによって暗号化さ
                 メッセージを表します。

               図 1: TLSフルハンドシェイクメッセージ


ハンドシェイクは上記図の3つのフェーズからなります。

 - 鍵交換
   キーマテリアルの共有と暗号パラメータを決定します。このフェーズ以降、
   すべてのメッセージは暗号化されます。

 - サーバパラメータ
   クライアント認証やアプリケーションレイヤープロトコルなど、他のハン
   ドシェイクパラメータを決定します。

 - 認証
   サーバの認証、および任意でクライアントの認証と、鍵とハンドシェイク
   の整合性の確認を行います。

鍵交換のフェーズでは、クライアントはランダムのnonce(ClientHello.random)
を含めたClientHelloメッセージ(Section 4.1.2)を送信します。これは、プロ
トコルバージョン、暗号/HKDFハッシュのリスト、Diffie-Hellman鍵共有
(Section 4.2.7の"key_share"拡張を参照)、事前共有鍵のラベル(Section 4.2.10
の"pre_shared_key"の設定、追加の拡張情報などを通知します。

サーバは、ClientHelloにより適切な暗号パラメータを決定します。その際に
ネゴシエーションする接続パラメータをServerHello(Section 4.1.3)にて応答
します。ClientHelloとServerHelloにより共有鍵を決定します。(EC)DHE鍵が
利用される場合、サーバはServerHelloの"key_share"拡張に、クライアントが
通知したグループと同じグループの一時Diffie-Hellman鍵を含めなければなり
ません[MUST]。PSKが利用される場合、サーバはServerHelloの"pre_shared_key"
拡張でクライアントが要求したPSKが選択されたかを通知します。実装は両方
の拡張が通知された場合、(EC)DHEとPSKを同時に使うことができることに留意
してください。

サーバは自身のパラメータの確立のため、2つのメッセージを送信します。

 EncryptedExtensions
  証明書以外に暗号パラメータを決定する必要がないClientHello拡張に応答
  します。
  [Section 4.3.1]

 CertificateRequest
  証明書を利用したクライアント認証が必要な場合、CertificateRequestによ
  って要求するパラメータを通知します。このメッセージはクライアント認証
  が不要な場合は必要ありません。
  [Section 4.3.2]

最後にクライアントとサーバは認証メッセージを交換します。TLSは認証が必
要な時は毎回、同じメッセージのセットを利用します。

 Certificate
  エンドポイントの証明書と、すべての証明書の拡張に利用されます。このメ
  ッセージは、証明書による認証が不要な場合はサーバによって、CertificateRequest
  メッセージがない場合はクライアントによって不要とされ、利用されません。
  もし生の公開鍵[RFC7250]やキャッシュ情報の拡張[RFC7924]が利用された場
  合、このメッセージは証明書ではなく、サーバの長期の鍵と一致する値とが
  含まれることに留意してください。
  [Section 4.4.2]

 CertificateVerify
  ハンドシェイク全体のシグネチャを証明書の秘密鍵で暗号化したメッセージ
  です。このメッセージは、エンドポイントが証明書による認証を不要とした
  場合は、必要ありません
  [Section 4.4.3]

 Finished
  ハンドシェイク全体のMAC(Message Authentication Code)です。このメッセ
  ージはエンドポイントの鍵交換によって生成された鍵の確認に利用します。
  PSKの場合はさらにハンドシェイクの認証にも利用します。
  [Section 4.4.4]

上記のサーバのメッセージを受信した場合、クライアントはCertificate、
CertificateVerify、Finishに応じた、クライアント側の認証メッセージを送
信します。

これらのメッセージのポイントは、クライアントとサーバは認証された暗号を
通して、アプリケーションデータを保護するレコードレイヤーのキーマテリア
ルを導出し、ハンドシェイクを完了させなければならないことです。アプリケ
ーションデータはFinishメッセージよりも前に暗号化されたレコードレイヤー
を送信してないけません[MUST NOT]。サーバは、クライアントの認証メッセー
ジを受ける前にレコードレイヤーを送信しますが、その時は認証されてないピ
アに送信することに注意してください。


2.1. DHE鍵共有の不一致について
もし、クライアントが適当な"key_share"拡張を提供しない場合(つまり、サー
バが受け付けないDHEまたはECDHEのグループしか送信しない場合)、サーバは
図2で示すように、HelloRetryRequestにより不一致を通知し、クライアントは
適切な"key_share"拡張により再度ハンドシェイクを行う必要があります。も
し共通する暗号パラメータがない場合、サーバは適切なアラートによりハンド
シェイクを破棄しなければなりません[MUST]。


            Client                                               Server

            ClientHello
            + key_share             -------->
                                    <--------         HelloRetryRequest
                                                            + key_share

            ClientHello
            + key_share             -------->
                                                            ServerHello
                                                            + key_share
                                                  {EncryptedExtensions}
                                                  {CertificateRequest*}
                                                         {Certificate*}
                                                   {CertificateVerify*}
                                                             {Finished}
                                    <--------       [Application Data*]
            {Certificate*}
            {CertificateVerify*}
            {Finished}              -------->
            [Application Data]      <------->        [Application Data]

                    図2: フルハンドシェイク時のパラメータの不一致

注意:初回のClientHello/HelloRetryRequestを含む、ハンドシェイクの複写は
新規のClientHelloをリセットしません。

以降のセクションに記載しますが、TLSは基本のハンドシェイクに、いくつか
の最適化のための変形を行うことができます。


2.2. セッションの再開と、事前鍵共有(PSK)
TLSのPSKは、通信の外でも確立することができますが、以前の通信や、セッショ
ンの再利用("session resumption")でも確立することができます。一度ハンド
シェイクが完了すると、サーバはクライアントに、初回ハンドシェイクによっ
て導出したユニークキーであるPSK IDを送信することができます。
クライアントは以降のハンドシェイクにPSK IDを利用することができます。も
しサーバがPSK IDを受け付けた場合、新しいコネクションのセキュリティコン
テキストは、オリジナルのコネクションに紐付いた暗号と、初回のハンドシェ
イクと同じキー導出により、フルハンドシェイクに代わり自力で暗号状態を確
立します。TLS 1.2やその前では、この機能は"session IDs"や"session tickets"[RFC5077]
によって提供されていました。この2つのメカニズムはTLS 1.3では廃止されて
います。

PSKは、(EC)DHE鍵交換を利用したforward secrecyで共有されるものや、また
はforward secrecy性は喪失するが、単体で発行できるアプリケーションデー
タによって共有されるものがあります。

図3は、PSKを通知する初回のネゴシエーションと、PSKを利用した2回目のネゴ
シエーションを示します。


          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               -------->
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                -------->
                                    <--------      [NewSessionTicket]
          [Application Data]        <------->      [Application Data]


   Subsequent Handshake:
          ClientHello
          + key_share*
          + psk_key_exchange_modes
          + pre_shared_key          -------->
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Finished}                -------->
          [Application Data]        <------->      [Application Data]

                    図3: セッションレジュームとPSKのメッセージ

サーバは、PSKによる認証が行われる場合、CertificateまたはCertificateVerify
メッセージを送信しません。クライアントがPSKによるセッションのレジュー
ムを要求するときは、必要であればクライアントはサーバがレジュームかフル
ハンドシェイクかを選択できるように"key_share"拡張を提供すべきです。サ
ーバは、"pre_shared_key"拡張をつけて、PSKのネゴシエーションの応答する
ことも、"key_share"拡張によりforward secrecyによる(EC)DHEでネゴシエー
ションすることもできます。

PSKが通信の外で提供されている場合、PSK IDとKDFハッシュアルゴリズムもま
た通信の外で提供されたものをPSKで利用しなければなりません[MUST]。
注意: 通信外で提供された事前共有鍵を使う時は、[RFC4086]で述べられてい
るように、エントロピー的に十分な鍵を生成するようによく考慮するべきです。
共有したパスワードや、他の低い情報量のソースから共有シークレットを導出
することはセキュアではありません。パスワードや低い情報量によるシークレ
ットではPSKに基づいた、辞書攻撃の対象となりえます。PSK認証は、Diffie-Hellman
鍵交換を行っていたとしても、パスワード認証による鍵の認証が決して強固な
ものではありません。


2.3. Zero-RTTデータ
クライアントとサーバが(外部または前のハンドシェイクによって得られた)PSK
を共有している時、TLS 1.3はクライアントの初回送信("early data")でデー
タを送ることができます。クライアントは、サーバの認証と、early dataの暗
号化のためにPSKを利用します。

クライアントが外部から得たPSKをearly dataの送信に利用する時は、以下の
追加情報を提供しなければなりません[MUST]。

 - PSKで利用するTLSのバージョン。
 - PSKで利用する暗号スイート。
 - 利用する場合は、Application-Layer Protocol Negotiation(ALPN)[RFC7301]。
 - 利用する場合は、Server Name Indication(SNI)。

図4に示すように、0-RTTデータは初回送信時に1-RTT時のハンドシェイクデー
タを追加したものです。その後のハンドシェイクはPSKレジュームによる1-RTT
ハンドシェイクと同様です。


            Client                                               Server

            ClientHello
            + early_data
            + key_share*
            + psk_key_exchange_modes
            + pre_shared_key
            (Application Data*)     -------->
                                                            ServerHello
                                                       + pre_shared_key
                                                           + key_share*
                                                  {EncryptedExtensions}
                                                          + early_data*
                                                             {Finished}
                                    <--------       [Application Data*]
            (EndOfEarlyData)
            {Finished}              -------->

            [Application Data]      <------->        [Application Data]

               +  前に書かれたメッセージの拡張として送信することを表し
                  ます。

               *  任意、または状況に応じてメッセージ/拡張を送信すること
                  を表します。必ず送信するものではありません。

               () client_early_traffic_secretによって導出された鍵によっ
                  て暗号化されたメッセージを表します。

               {} [sender]_handshake_traffic_secretによって暗号化された
                  メッセージを表します。

               [] [sender]_application_traffic_secret_Nによって暗号化さ
                  メッセージを表します。

                       図4: 0ラウンドトリップハンドシェイク

重要な注意:0-RTTデータは他のTLSのデータよりもセキュリティ特性が弱いです。
           具体的には、下記のことに注意してください。

 1. このデータはPSKによって導出された鍵で暗号化しているだけのため、forward
    secret特性を持っていません。
 2. コネクション間で再利用されないことは保証されていません。本来のTLS 1.3
    の1-RTTデータはサーバランダム値によって、リプレイ攻撃への耐性を持
    っていますが、0-RTTデータはServerHelloに依存しないためです。これは、
    クライアント認証や、アプリケーションプロトコルのデータに特に関連し
    ます。同じことがearly_exporter_master_secretにも言えます。

0-RTTデータはコネクション内で複製できません(つまりサーバは同じコネクショ
ン上での同一データを2度は受け付けません)。また攻撃者は1-RTTデータに0-RTT
のデータを利用することはできません(別の鍵によって暗号化するため)。
Appendix E.5に攻撃の可能性についての記述と、Section 8にリプライ攻撃に
対抗するための上限を設けることについて記述しています。



3. 記法について
このドキュメントのデータ記法は、非常に基本的かつお馴染みの文法が利用さ
れています。


3.1. ベースのブロックサイズ
すべてのデータは明確に指定されて表現されています。ベースとなるブロック
サイズは1バイト(つまり8bit)です。複数バイトのものは、左から右、上から
下へのバイトの連結として表現されます。マルチバイトのバイトストリームは
次のように記述されます。

    value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
            ... | byte[n-1];

このマルチバイト値のバイトオーダはネットワークバイトオーダまたはビッグ
エンディアンです。


3.2. その他
コメントは"/*"と"*/"に囲まれています。

任意の構成要素は、"[[ ]]"内に書かれます。

バイトの集合のような、他に解釈できないようなデータはopaqueとして表現し
ます。


3.3. ベクトル
ベクトル(一次元配列)は、同質の要素のストリームです。ベクトルのサイズは、
ドキュメントの記載時か実行時に指定されます。どちらのケースでも、ベクト
ルは要素数ではなく、バイト数で長さが定義されます。
固定長のベクトルTをタイプにもった、新しく定義するベクトルのタイプをT'
とする場合、以下の表記となります。

    T T'[n];

ここでは、T'はTの倍数のサイズ分であるnバイト分のデータストリームです。

次の例では、Datumは3つの連続したバイトの定義です。Dataは3つのDatumによ
って構成される、合計9バイトの構造です。

    opaque Datum[3];
    Datum Data[9];

可変長のベクトルは特定の部分を指定した、<floor..ceiling>の表記で定義さ
れます。これらでエンコードされた時、実際の長さはバイトストリームのベク
トルの内容より優先されます。必要以上の長さのデータがあった場合、最大サ
イズまでで留めておきます。可変長データのベクトルの実際のフィールドが0
であった場合、空のベクトルとして扱います。

    T T'<floor..ceiling>;

次の例の1つ目のmandatoryは、長さが300〜400バイトが必須のopaqueタイプの
ベクトルです。これは空となることがありません。実際の長さのフィールドは
2バイトのUint16で、400が上限になります(Section 3.4参照)。同じように、
2つ目のlongerは上限が800バイトで、uint16のため400個の要素が上限で、空
となる場合もあります。このエンコードの2バイトの長さのフィールドはベク
トルの要素よりも前に置かれます。ベクトルの長さは1つの要素の倍数となら
なければなりません。(つまり、uint16のベクトルで長さが17バイトとなるの
は異常とみなされます)

    opaque mandatory<300..400>;
        /* 長さのフィールドは2バイトで、空になることはありません */
    uint16 longer<0..800>;
        /* 0から400の16bitの符号なし整数です */


3.4. 数値型
基本の数値型のデータは符号なしバイト(uint8)です。より大きな数値型のデ
ータはSection 3.1で記述したように、バイト(uint8)が固定長連結することで
形成されます。次のナンバータイプは事前定義されています。

    uint8 uint16[2];
    uint8 uint24[3];
    uint8 uint32[4];
    uint8 uint64[8];

すべての値は、ここか他の場所で定義されます。また、ネットワークバイトオ
ーダ(big-endian)で格納されます。;uint32の値を16進で表される、01 02 03 04
の値は10進の16909060の値になります。


3.5. 列挙型
値に弱い関連付けがされているデータのタイプをenumと呼びます。各定義は別
のタイプです。同じタイプの列挙型のみを関連、比較する対象とすることがで
きます。すべての列挙型の要素は、以下の例のように値と関連付けられていま
す。列挙型の要素の順序に意味はないため、どのような順番でもユニークな値
を関連付けることができます。

    enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;

プロトコルの拡張や追加のため、新しい値が定義されていきます。実装ではパ
ースした際に、フィールドの状態が違っていない限り、未知の値を無視する必
要があります。

列挙型では、最大値の定義に合わせたサイズのバイトストリームを専有します。
次の定義では、Colorタイプとして1バイトのフィールドを定義しています。

    enum { red(3), blue(5), white(7) } Color;

これは、余分な要素もなく、強制的にタグと関連付けられていないものの例で
す。

次のTasteの例では、2バイトのデータですが、値は現状は1,2,4しか定義され
ていません。

    enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

列挙型の要素の名前は、スコープ内に定義されたタイプになります。最初の例
の2番めの要素を完全修飾形式で書く場合 Color.blue のようになります。対
象が特定できる場合は、このような書き方は不要になります。

    Color color = Color.blue;    /* 過剰な記述方式ですが、問題ありません */
    Color color = blue;          /* 正しい記述方式です。タイプは暗黙的です */

名前への関連付けは、ユニークである必要はありません。列挙の値は2つのピ
リオドを間に入れた書き方で、範囲で同じ名前を適用することができます。こ
れは、スペースを予約しておく上で、非常に便利な方法です。

    enum { sad(0), meh(1..254), happy(255) } Mood;


3.6. 構造体
構成を簡易に書くため、基本型から構成される構造体を利用できます。各宣言
は、ユニークなものになります。記法は、C言語のように定義します。

    struct {
        T1 f1;
        T2 f2;
        ...
        Tn fn;
    } [[T]];

構造体のフィールドは、列挙型と同じように、タイプ名を利用した修飾子にな
ります。例えば、T.f2は上で書かれた宣言の2番目の要素への参照となります。
構造体は他の構造体に埋め込まれて定義されることがあります。どの構造体も
他で定義されているものになります。


3.7. 定数
固定値に関連付けられるものは、"="を使って、以下のように記述されます。

    struct {
        T1 f1 = 8;   /* T.f1 は必ず8である必要があります */
        T2 f2;
    } T;


3.8. 可変構造
実際の動作時に得られる値を元にして、解釈する構造を変更させる定義を行う
ことができます。selectorは、構造体の定義で取りうる範囲の変数でなければ
なりません。可変構造の決定因子はラベルの参照によって記述されます。この
ような実行時の変数によって選択される構造は、表現時の記法の段階では決定
されていません。

    struct {
        T1 f1;
        T2 f2;
        ....
        Tn fn;
        select (E) {
            case e1: Te1;
            case e2: Te2;
            ....
            case en: Ten;
        } [[fv]];
    } [[Tv]];

例:

    enum { apple(0), orange(1) } VariantTag;

    struct {
        uint16 number;
        opaque string<0..10>; /* variable length */
    } V1;

    struct {
        uint32 number;
        opaque string[10];    /* fixed length */
    } V2;

    struct {
        VariantTag type;
        select (VariantRecord.type) {
            case apple:  V1;
            case orange: V2;
        };
    } VariantRecord;



4. ハンドシェイクプロトコル
ハンドシェイクプロトコルは、コネクションのセキュリティパラメータをネゴ
シエーションするために使われます。ハンドシェイクメッセージは、コネクショ
ンの状態により、1つ以上のカプセル化されたTLSPlaintextまたは、TLSCiphertext
のTLSレコードレイヤーによって行われます。

    enum {
        client_hello(1),
        server_hello(2),
        new_session_ticket(4),
        end_of_early_data(5),
        hello_retry_request(6),
        encrypted_extensions(8),
        certificate(11),
        certificate_request(13),
        certificate_verify(15),
        finished(20),
        key_update(24),
        message_hash(254),
        (255)
    } HandshakeType;

    struct {
        HandshakeType msg_type;    /* handshake type */
        uint24 length;             /* bytes in message */
        select (Handshake.msg_type) {
            case client_hello:          ClientHello;
            case server_hello:          ServerHello;
            case end_of_early_data:     EndOfEarlyData;
            case hello_retry_request:   HelloRetryRequest;
            case encrypted_extensions:  EncryptedExtensions;
            case certificate_request:   CertificateRequest;
            case certificate:           Certificate;
            case certificate_verify:    CertificateVerify;
            case finished:              Finished;
            case new_session_ticket:    NewSessionTicket;
            case key_update:            KeyUpdate;
        } body;
    } Handshake;

プロトコルメッセージは、Section 4.4.1で定義された、およびSection 2で示
している順序で送信しなければあなりません[MUST]。通信相手から予期しない
順序でハンドシェイクメッセージを受信した場合、"unexpected_message"のア
ラートを送信し、ハンドシェイクを破棄しなければなりません[MUST]。


4.1. 鍵交換メッセージ
鍵交換メッセージは、後のハンドシェイクやデータを保護するためのトラフィ
ックキーを含めた、セキュリティパラメータを共有するため、クライアントと
とサーバのセキュリティ能力の決定に利用されます。


4.1.1. 暗号のネゴシエーション
TLSでは、暗号のネゴシエーションは、ClientHelloの次の4つのオプションの
要求で、クライアントから開始されます。

 - クライアントがサポートしている、AEADアルゴリズム/HKDFハッシュペアの
   暗号スイートのリスト。

 - クライアントがサポートしている(EC)DHEグループを"supported_groups"拡
   張(Section 4.2.6)と、このグループのための(EC)DHE共有の"key_share"拡
   張(Section 4.2.7)。

 - クライアントが受け入れ可能なシグネチャアルゴリズムを通知する、
   "signature_algorithms"拡張(Section 4.2.3)。

 - クライアントが知っている対称鍵のリストを含んだ"pre_shared_key"拡張
   (Section 4.2.10)および、PSKを利用する鍵交換方式を通知する
   "psk_key_exchange_modes"拡張(Section 4.2.8)。   

サーバがPSKを選択しない場合、上の3つのオプションはそれぞれ独立していま
す。サーバは、暗号スイートと、鍵を確立するための(EC)DHEグループと鍵共
有のペアと、クライアントに自身の認証させるためのシグネチャアルゴリズム
と証明書のペアとを独立して選択することができます。もし、受信した
"supported_groups"とサーバがサポートしているグループとに一致するものが
なかった場合は、サーバは"handshake_failure"か、"insufficient_security"
アラートを送信してハンドシェイクを破棄しなければなりません[MUST]。

サーバがPSKを選択した場合、鍵を確立する方式も、クライアントから通知さ
れた"psk_key_exchange_modes"拡張(現状は、PSKのみか(EC)DHEを伴います)か
ら選択する必要があります[MUST]。(EC)DHEを伴わないPSKを使う場合、前の節
での非PSKのケースとは異なり、"supported_groups"パラメータが一致しない
ことは致命的にはならないことに注意してください。

サーバが(EC)DHEグループを選択し、クライアントが適合する"key_share"拡張
を初回のClientHelloに提供しない場合、サーバはHelloRetryRequestメッセー
ジ(Section 4.1.4)を応答しなければなりません[MUST]。

サーバがパラメータの選択に成功し、HelloRetryRequestも不要であった場合、
選択したパラメータSeverHelloにて下記のように通知します。

 - PSKを利用する場合、サーバーは"pre_shared_key"拡張に選択した鍵を入れ
   て送信します。

 - PSKを利用しない場合は必ず(EC)DHEと証明書ベースの認証を利用します。

 - (EC)DHEが利用される時は、サーバは"key_share"拡張もまた提供します。

 - 証明書による認証を行う時は、サーバはCertificateメッセージ(Section 4.4.2)
   とCertificateVerifyメッセージ(Section 4.4.3)を送信する。TLS 1.3を規
   定するこの文書では、PSKと証明書のどちらかは必ず利用されるが、両方を
   同時に利用することはない。ただし、将来的に両方を同時に利用する方法
   を定義する可能性はあります。

サーバがサポートするパラメータのセットを折衝できない場合(つまり、クラ
イアントとサーバ間で一致するパラメータがない場合)、"handshake_failure"
または"insufficient_security"のfatalアラートでハンドシェイクを破棄する
必要があります[MUST]。(Section 6を参照)


4.1.2. Client Hello
クライアントが最初にサーバと接続する時、最初のメッセージとしてClientHello
の送信が要求されます[REQUIRED]。クライアントはサーバがClientHelloに対
してHelloRetryRequestを応答した場合もまた、ClientHelloを送信します。こ
の場合、クライアントは下記の場合を除いて、改変することなしに同じClientHello
を送信しなければなりません[MUST]。

 - HelloRetryRequestに"key_share"拡張が提供されている場合、通知された
   グループに含まれる、1つのKeyShareEntryの共有リストに置き換えます。

 - もし"early_data"拡張(Section 4.2.9)があった場合は削除します。Early
   dataはHelloRetryRequestの後は利用できません。

 - HelloRetyrRequestに"cookie"拡張が提供されている場合は、それを取り込
   みます。

 - "pre_shared_key"拡張がある場合、"obfuscated_ticket_age"によって再計
   算を行い、値を更新します。また、サーバの通知した暗号スイートとPSKは
   任意で削除しても構いません。

TLS 1.3は再ネゴシエーションを禁止しているため、サーバが他のタイミング
でClientHelloを受信した場合、"unexpected_message"アラートにより、コネ
クションを終了しなければなりません[MUST]。

サーバがTLS 1.3より前のバージョンのコネクションを確立している時に、
TLS 1.3のClientHelloの再ネゴシエーションを受けた場合、前バージョンを保
持し続けなければなりません[MUST]。特に、TLS 1.3でネゴシエーションは行
ってはいけません[MUST NOT]。


ClientHelloメッセージ構造:

    uint16 ProtocolVersion;
        opaque Random[32];
      
        uint8 CipherSuite[2];    /* Cryptographic suite selector */
      
        struct {
            ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
            Random random;
            opaque legacy_session_id<0..32>;
            CipherSuite cipher_suites<2..2^16-2>;
            opaque legacy_compression_methods<1..2^8-1>;
            Extension extensions<8..2^16-1>;
        } ClientHello;

 legacy_version
  前のTLSバージョンでは、このフィールドはバージョンのネゴシエーション
  とクライアントがサポートしている最も新しいバージョンを通知するために
  利用されていました。経験的に多くのサーバは正しくバージョンのネゴシエ
  ーションを実装しておらす、サーバは自身がサポートしているよりも高いバ
  ージョンのClientHelloを受け付けない、バージョンに不寛容であることが
  わかっています。TLS 1.3では、バージョンの設定を"supported_versions"
  拡張(Section 4.2.1)で通知し、legacy_versionフィールドはTLS 1.2である
  0x0303が設定されなければなりません[MUST]。

 random 
  セキュアな乱数生成機によって生成された32バイトの値。
  Appendix Cの追加情報を参照。

 legacy_session_id
  TLS 1.3より前のTLSでは、このバージョンでPre-Shared Keys(Section 2.2参照)
  に統合された、"session resumption"をサポートしていました。このフィー
  ル  ドはTLS 1.3をネゴシエーションするサーバは無視する必要があります[MUST]。
  また、クライアントはTLS 1.3より前のサーバによるセションIDをキャッシュ
  してはならず、長さ0のベクトル(つまり、0バイトの長さのフィールド)を設
  定しなければなりません[MUST]。

 cipher_suites
  クライアントがサポートしている対称暗号のリストです。具体的には、レコ
  ード保護アルゴリズム(秘密鍵の長さを含む)と、HKDFに利用されるハッシュ
  とがクライアントが優先する順番で通知します。このリストに含まれる暗号
  スイートがサーバで認識できない、サポートしない、利用を望まない場合は
  サーバはその暗号スイートを無視して、残りの暗号スイートを見ていかなけ
  ればなりません[MUST]。値はAppendix B.4で定義されています。クライアン
  トがPSK鍵を確立しようとするなら、少なくとも1つのPSKに関連したハッシュ
  の暗号スイートを通知するべきです[SHOULD]。

 legacy_compression_methods
  TLS 1.3より前のバージョンでは、このフィールドにサポートしている圧縮
  メソッドのリストを送信していました。TLS 1.3のすべてのClientHelloでは、
  このベクトルには前のバージョンで"null"圧縮を表す1バイトの0の値を設定
  しなければなりません[MUST]。このフィールドに他の値を含んだTLS 1.3の
  ClientHelloを受信した場合、サーバは"illegal_parameter"アラートにより
  ハンドシェイクを破棄しなければなりません[MUST]。TLS 1.3サーバはTLS 1.2
  より前のバージョンの他の圧縮メソッドを含んだClientHelloを受信する可
  能性がありますが、その場合は以降に記述する手順で前バージョンのTLSに
  しなければならない[MUST]ことに留意してください。TLS 1.3のClientHello
  は、0x0303のlegacy_versionによりTLS 1.2と同一に見えますが、
  suppoerted_version拡張により、0x0304の最も高いバージョンを通知します。

 extensions
  クライアントはextensionsフィールドにより、サーバへ拡張機能を要求しま
  す。"Extension"のフォーマットはSection 4.2に定義されています。TLS 1.3
  では、前のバージョンのClientHelloに存在した機能が、拡張へと移動され
  ているため、特定の拡張は必須となっています。サーバは理解できない拡張
  については無視しなければなりません[MUST]。

すべてのTLSバージョンは、compression_methodフィールドの後ろに、任意で
拡張フィールドを付けることができます。TLS 1.3のClientHelloメッセージは
必ず拡張を含める必要があります(少なくとも、"supported_versions"はTLS 1.2
のClientHelloと区別するため)。しかし、TLS 1.3サーバは拡張フィールドが
ない、前のバージョンのClientHelloメッセージを受ける可能性があります。
ClientHelloのcompression_methodsフィールドの後ろの拡張の存在の判定によ
り検知することができます。この任意のデータの検知は、通常のTLSの可変フィ
ールドとは異なりますが、以前のTLSの拡張の定義と互換性があるように利用
されることに留意してください。TLS 1.3サーバは、TLS 1.3でネゴシエーショ
ンする場合は"supported_version"拡張の存在を最初にチェックする必要があ
ります。TLS 1.3より前のバージョンのTLSでネゴシエーションする場合、サー
バはlegacy_compression_methodsより後にデータがないか、データ無しの有効
な拡張ブロックを含んでいることをチェックしなければなりません[MUST]。も
しそうではないなら、"decode_error"アラートによりハンドシェイクを破棄し
なければなりません[MUST]。

クライアントが拡張機能を追加した要求を行った時で、その機能をサーバがサ
ポート指定なかった場合、クライアントはハンドシェイクを破棄することがで
きます[MAY]。

ClientHelloメッセージの送信後、クライアントはServerHelloかHelloRetryRequest
メッセージを待ちます。early dataを利用する場合、クライアントは次のハン
ドシェイクメッセージを待つ間、Section 2.3のearly application dataを送
信することができます。


4.1.3. Server Hello
サーバはClientHelloのパラメータが受付可能なものであった場合、ハンドシェ
イクを継続するため、応答としてServerHelloメッセージを送信します。

ServerHelloメッセージ構造:

    struct {
        ProtocolVersion version;
        Random random;
        CipherSuite cipher_suite;
        Extension extensions<6..2^16-1>;
    } ServerHello;

 version
  このフィールドはこのコネクションで利用するTLSバージョンを格納します。
  サーバはClientHelloのsupported_varsion拡張のリストからバージョンを選
  択するか、TLS 1.2以前のバージョンでネゴシエーションを行わなければな
  りません[MUST]。クライアントは、望まないバージョンを受けた場合、ハン
  ドシェイクを破棄しなければなりません[MUST]。このTLS 1.3の値は、0x0304
  です。(後方互換についての詳細はAppendix Dを参照してください)

 random
  セキュアな乱数生成機によって生成された32バイトの値です。
  Appendix Cの追加情報を参照。
  TLS 1.2とTLS 1.1でネゴシエーションを行う場合、最後の8バイトは後述に
  あるように上書きする必要がありますが、他はランダムのままである必要が
  あります[MUST]。この値は、ClientHello.randomとは独立して、サーバによ
  って生成されなければなりません[MUST]。

 cipher_suite
  ClientHello.cipher_suitesのリストからサーバによって選択された1つの暗
  号スイートの値です。クライアントは、要求していない暗号スイートを受け
  た場合、"illegal_parameter"のアラートによりハンドシェイクを破棄しな
  ければなりません[MUST]。

 extensions
  拡張機能のリストです。ServerHelloは暗号コンテキストを確立するために
  要求された拡張のみを含めなければなりません[MUST]。今のところ、"key_share"
  や  "pre_shared_key"などの拡張のみです。現状、すべてのTLS 1.3 ServerHello
  メッセージは前述の2つの拡張、または(EC)DHE鍵で確立するPSKを利用する
  かのいずれか一方、あるいは両方を含めます。他の拡張はEncryptedExtensions
  メッセージとして送信されます。

TLS 1.3はサーバランダムにダウングレード保護のメカニズムを持っています。
TLS 1.3サーバはTLS 1.2以前のバージョンとして、ClientHelloに応答する場
合、最後の8バイトを特定の値にする必要があります[MUST]。

TLS 1.3サーバがTLS 1.2でネゴシエーションを行う場合、サーバランダムの値
を次のように設定しなければなりません[MUST]。

 44 4F 57 4E 47 52 44 01

TLS 1.1以前のバージョンでネゴシエーションを行う場合、サーバランダムの
値を次のように設定しなければなりません。これは、TLS 1.3サーバは必須で
あり[MUST]、TLS 1.2サーバは推奨の[SHOULD]動作です。

 44 4F 57 4E 47 52 44 00
 
TLS 1.3クライアントは、TLS 1.2以前のServerHelloを受信した場合、サーバ
ランダムの最後の8バイトが上記の値に一致していないことをチェックする必
要があります[MUST]。TLS 1.2クライアントもまた、TLS 1.1以前のServerHello
を受信した場合、サーバランダムの最後の8バイトが上記の2つ目の値に一致し
ていないことをチェックすべきです[SHOULD]。もし値の一致があるのであれば、
クライアントは"illegal_parameter"のアラートによってハンドシェイクを破
棄しなければなりません[MUST]。これは、Finishedの交換で行われるダウング
レード攻撃に対する保護メカニズムです。これは、クライアントとサーバのラ
ンダム値によるシグネチャを含んだ、TLS 1.2以前にあるServerKeyExchangeメ
ッセージが、攻撃者によって脆弱なものに書き換えられたことを検知できない
ためです。このダウングレード保護は、静的なRSAを利用する場合は提供され
ません。

注意:これは[RFC5246]より変更された点であるため、実際の多くのTLS 1.2ク
ライアントやサーバは上記の振る舞いを行いません。

レガシーのTLSクライアントは、TLS 1.2以前にある再ネゴシエーションを行え
ますが、再ネゴシエーション中にTLS 1.3のServerHelloを受信した場合は、
"protocol_version"のアラートによってハンドシェイクを破棄しなければなり
ません[MUST]。TLS 1.3でネゴシエーションをしている場合は、再ネゴシエー
ションを行うことはできないことに注意してください。

RFC EDITOR:この文章は削除される予定です
ドラフトバージョンの実装(Section 4.2.1.1参照)では、クライアントおよび
サーバに、この実装を行うべきではありません。RFC化前のクライアントがRFC
化後のサーバに接続する、またはその逆では、TLS 1.2にダウングレードする
ようにすべきです。このメカニズムを有効にする場合、相互的に失敗が起きる
ようにするべきです。


4.1.4. Hello Retry Request
サーバは、ClientHelloに受け入れ可能なパラメータはあるが、ハンドシェイ
クを進める情報が十分になかった場合、応答としてHelloRetryRequestメッセ
ージを送信します。

HelloRetryRequestメッセージ構造:

    struct {
        ProtocolVersion server_version;
        CipherSuite cipher_suite;
        Extension extensions<2..2^16-1>;
    } HelloRetryRequest;

version、cipher_suite、extensionsフィールドは、ServerHelloのものと同じ
意味を持っています。サーバはクライアントのClientHelloに必要な拡張のみ
を送信すべきです。ServerHelloと同様に、HelloRetryRequestは、"cookie"拡
張(Section 4.2.2参照)を除き、最初に提供されたクライアントのClientHello
に要求されていない拡張を含めてはいけません[MUST NOT]。

HelloRetryRequestを受信した場合、クライアントはその拡張ブロックが空で
はないことを確認しなければなりません[MUST]。空であった場合、"decode_error"
アラートによりハンドシェイクを破棄しなければなりません[MUST]。クライア
ントは、HelloRetryRequestがClientHelloから何らかの変更が行われている場
合、"illegal_parameter"アラートによりハンドシェイクを破棄しなければな
りません[MUST]。もし同じコネクション上で2回めのHelloRetryRequestを受け
た場合(つまり、HelloRetryRequestの応答のClientHelloでHelloRetryRequest
を受けた場合)、"unexpected_message"アラートによりハンドシェイクを破棄
しなければなりません[MUST]。

つまり、クライアントはHelloRetryRequestのすべての拡張を受け付け、更新
した2つ目のClientHelloを送信しなければなりません[MUST]。HelloRetryRequest
の拡張の定義は次のようになっています。

 - cookie(Section 4.2.2参照)

 - key_share(Section 4.2.7参照)

加えて、ClientHelloの更新には、クライアントは選択した暗号スイートに関
連しない事前共有鍵を要求すべきではありません[SHOULD NOT]。これは、クラ
イアントが2つ目のClientHelloで複数のハッシュの計算を避けるためです。要
求していない暗号スイートを受け取ったクライアントはハンドシェイクを破棄
しなければなりません[MUST]。サーバは更新されたClientHelloに合った暗号
スイートによるネゴシエーションを保証しなければなりません[MUST]。ServerHello
を受信した上で、クライアントは暗号スイートにHelloRetryRequestで要求し
たものが提供されていることをチェックしなければならず[MUST]、提供されて
いなかった場合は"illegal_parameter"アラートによりハンドシェイクを破棄
します。


4.2. Extensions
多くのTLSメッセージは、タグ長によってエンコードされた拡張構造を含んで
います。


    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;

   enum {
       server_name(0),                             /* RFC 6066 */
       max_fragment_length(1),                     /* RFC 6066 */
       status_request(5),                          /* RFC 6066 */
       supported_groups(10),                       /* RFC 4492, 7919 */
       signature_algorithms(13),                   /* RFC 5246 */
       use_srtp(14),                               /* RFC 5764 */
       heartbeat(15),                              /* RFC 6520 */
       application_layer_protocol_negotiation(16), /* RFC 7301 */
       signed_certificate_timestamp(18),           /* RFC 6962 */
       client_certificate_type(19),                /* RFC 7250 */
       server_certificate_type(20),                /* RFC 7250 */
       padding(21),                                /* RFC 7685 */
       key_share(40),                              /* [[this document]] */
       pre_shared_key(41),                         /* [[this document]] */
       early_data(42),                             /* [[this document]] */
       supported_versions(43),                     /* [[this document]] */
       cookie(44),                                 /* [[this document]] */
       psk_key_exchange_modes(45),                 /* [[this document]] */
       certificate_authorities(47),                /* [[this document]] */
       oid_filters(48),                            /* [[this document]] */
       post_handshake_auth(49),                    /* [[this document]] */
       (65535)
   } ExtensionType;

 - "extension_type"は拡張の種類を特定します。
 - "extension_data"は特定の拡張の種類の情報を格納します。

拡張種類のリストは、Section 11で述べられているように、IANAによってメン
テナンスされています。

拡張は、通常はリクエスト/レスポンス形式の構造を取りますが、いくつかの
拡張はレスポンスを不要とする、通知のみのものもあります。クライアントは
ClientHelloメッセージでリクエストの拡張を送信し、サーバはこれに対する
応答の拡張をServerHello、EncryptedExtensions、HelloRetryRequestおよび
Certificateメッセージに載せて送信します。サーバのリクエストの拡張は、
クライアントの認知のCertificateメッセージ応答[MAY]に対する要求を
CertificateRequestメッセージにて送信します。サーバはまた、クライアント
が直接応答しなくても、NewSessionTicketに要求されていない拡張を送信する
ことができます[MAY]。

実装として、リモートのエンドポイントが"cookie"拡張を除き、一致する拡張
リクエストを拡張を送信してこなかった場合、それに応じる拡張を応答しては
なりません[MUST]。そのような拡張を受信した場合は、エンドポイントは
"unsupported_extension"アラートにより、ハンドシェイクを破棄しなければ
なりません[MUST]。

次の表は、各メッセージに付与できる拡張を記載しています。
表記として: CH (ClientHello)、SH (ServerHello)、EE (EncryptedExtensions)、
CT (Certificate)、CR (CertificateRequest)、NST (NewSessionTicket)、
HRR (HelloRetryRequest)になります。実装として、解釈はできるがメッセー
ジに紐付かない拡張を受信した場合は、"illegal_parameter"アラートにより
ハンドシェイクを破棄しなければなりません[MUST]。

    +--------------------------------------------------+-------------+
    | Extension                                        |     TLS 1.3 |
    +--------------------------------------------------+-------------+
    | server_name [RFC6066]                            |      CH, EE |
    |                                                  |             |
    | max_fragment_length [RFC6066]                    |      CH, EE |
    |                                                  |             |
    | status_request [RFC6066]                         |  CH, CR, CT |
    |                                                  |             |
    | supported_groups [RFC7919]                       |      CH, EE |
    |                                                  |             |
    | signature_algorithms [RFC5246]                   |      CH, CR |
    |                                                  |             |
    | use_srtp [RFC5764]                               |      CH, EE |
    |                                                  |             |
    | heartbeat [RFC6520]                              |      CH, EE |
    |                                                  |             |
    | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
    |                                                  |             |
    | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
    |                                                  |             |
    | client_certificate_type [RFC7250]                |      CH, EE |
    |                                                  |             |
    | server_certificate_type [RFC7250]                |      CH, CT |
    |                                                  |             |
    | padding [RFC7685]                                |          CH |
    |                                                  |             |
    | key_share [[this document]]                      | CH, SH, HRR |
    |                                                  |             |
    | pre_shared_key [[this document]]                 |      CH, SH |
    |                                                  |             |
    | psk_key_exchange_modes [[this document]]         |          CH |
    |                                                  |             |
    | early_data [[this document]]                     | CH, EE, NST |
    |                                                  |             |
    | cookie [[this document]]                         |     CH, HRR |
    |                                                  |             |
    | supported_versions [[this document]]             |          CH |
    |                                                  |             |
    | certificate_authorities [[this document]]        |      CH, CR |
    |                                                  |             |
    | oid_filters [[this document]]                    |          CR |
    |                                                  |             |
    | post_handshake_auth [[this document]]            |          CH |
    +--------------------------------------------------+-------------+

複数の別のタイプの拡張がある時は、拡張の順序は"pre_shared_key"を除いて
どのような順番でも問題ありません[MAY]。Section 4.2.10に記載の"pre_shared_key"
はClientHelloの拡張の最後尾になければなりません[MUST]。拡張は、同じ拡
張ブロックに、複数の同一タイプの拡張を入れてはいけません[MUST NOT]。

TLS 1.3ではTLS 1.2と異なり、PSKのレジュームでも、拡張は各ハンドシェイ
クでネゴシエーションが行われます。しかし、0-RTTパラメータは事前のハン
ドシェイクでネゴシエーションされ、合わない場合は0-RTTは拒否されます
(Section 4.2.9参照)。

新しいプロトコルと既存のプロトコルとには、微細な(または微細ではない)相
互作用として、全体のセキュリティ性の重大な減少が発生するかもしれません。
次に新しい拡張を設計する上での取るべき考えを考察しています。

 - いくつかの場合、サーバは同意しない拡張をエラー状態としたり、ただ単
   にサポートしている特定の機能のみを選択します。一般的にエラーアラー
   トは前者で返し、応答の拡張フィールドは後者で返します。

 - 拡張は可能な限り、力任せの(力任せではなくとも)攻撃を防ぐように設計
   されるべきです。この原則は、セキュリティ上の問題を引き起すような機
   能に   関係なく守られるべきです。事実として、拡張フィールドまでを
   Finishメッセージの入力とすることはセキュリティ的に十分ではあります
   が、ハンドシェイクフェーズでメッセージの意味を変更する際は、特段の
   注意が必要です。設計者および実装者は、攻撃者がメッセージの改変や拡
   張の挿入、削除、置き換えが可能であり、それが認証されたハンドシェイ
   クとなることまでを想定しておくべきです。


4.2.1. Supported Versions

    struct {
        ProtocolVersion versions<2..254>;
    } SupportedVersions;

"supported_versions"拡張は、クライアントが自身のサポートしているTLSバ
ージョンを通知するために使用されます。拡張には、優先度が高い順番でサポ
ートバージョンのリストを含んでいます。実装の詳細として、この拡張には利
用できるすべてのTLSバージョンを入れて送信しなければなりません[MUST]。
(実装として、最小構成は0x0304を含める必要がありますが、もし以前のTLSバ
ージョンのネゴシエーションが可能であれば、それらも追加されるべきです[MUST])。

この拡張がなかった場合、たとえClientHello.legacy_versionが0x0304以降で
あったとしても、サーバは[RFC5246]のTLS 1.2以前のバージョンでネゴシエー
ションを行う必要があります[MUST]。サーバはClientHelloのlegacy_version
が0x0304以降にあった場合、ハンドシェイクを破棄しても構いません[MAY]。

拡張が存在した場合は、サーバはClientHello.legacy_versionの値を無視すべ
きで[MUST]、"supported_versions"拡張のみによってクライアントの設定を決
定しなければなりません[MUST]。サーバは拡張からのみ利用するTLSバージョ
ンを選択し[MUST]、不明なバージョンは無視しなければなりません[MUST]。こ
れは一方のサポート範囲が異なっていても、TLS 1.2以前のバージョンとのネ
ゴシエーションを可能にするためのメカニズムという点に留意シてください。
以前のバージョンをサポートするTLS 1.3の実装は、TLS 1.2をサポートすべき
です[SHOULD]。サーバは、ClientHelloにこの拡張を含むが、その中のリスト
に0x0304を含まないものを受信した時の用意をしておくべきです。

サーバは"supported_versions"拡張を送信してはいけません[MUST NOT]。サー
バが選択したバージョンは、以前のTLSバージョンのように、ServerHello.version
フィールドに格納されます。


4.2.1.1. ドラフトバージョンの通知

RFC EDITOR:この文章は削除される予定です

最終的にRFCとして、TLS 1.3のバージョンは0x0304になりますが、ドラフトバ
ージョンの実装は代わりにServerHello.versionとHelloRetryRequest.server_version
には{0x7f,draft_version}を通知すべきです[SHOULD]。例えば、draft-17では
{0x7f, 0x11}としてエンコードされます。これは、RFC化前の実装において、
たとえ互換性がなくとも、互いに安全にネゴシエーションを行うためのもので
す。


4.2.2. Cookie

    struct {
        opaque cookie<1..2^16-1>;
    } Cookie;

Cookiesは2つの主目的を果たします。

 - サーバがクライアントに対し、強制的に到達可能なネットワークアドレス
   を開示させます(つまり、DoSを防御するかを判断する材料を提供します)。
   これは到達不可能なコネクションに対して有用性があります([RFC6347]の
   例を参照)。

 - サーバがクライアントに状態の管理を任せることができます。つまり、ど
   のような状態でもHelloRetryRequestが送信できます。サーバはHelloRetryRequest
   のcookieに、ClientHelloのハッシュを入れることで、これができます。
   (適切なアルゴリズムによって保護されます)。

HelloRetryRequestを送信した時は、サーバは"cookie"拡張をクライアントに
提供することができます[MAY](これは、この拡張のみのもので、ClientHello
の通常のルールの例外になります)。新規のClientHelloを送信する際、クライ
アントは新規のClientHelloの"cookie"拡張に、受信したHelloRetryRequestの
拡張を複写しなければなりません[MUST]。クライアントはその後のコネクショ
ンではcookieを使用してはいけません[MUST NOT]。


4.2.3. Signature Algorithms
クライアントはデジタル署名に使われる可能性のあるシグネチャアルゴリズム
を"signature_algorithms"拡張によってサーバに通知します。証明書によって
サーバの認証を行いたい場合は、クライアントはこの拡張を送信する必要があ
ります[MUST]。サーバが証明書による認証を行っている場合かつ、クライアン
トが"signature_algorithms"を送信しない場合、サーバは"missing_extension"
アラートによりハンドシェイクを破棄しなければなりません[MUST](Section 9.2参照)。

ClientHelloの、この拡張の"extension_data"フィールドはSignatureSchemeList
の値が格納されます。

    enum {
        /* RSASSA-PKCS1-v1_5 algorithms */
        rsa_pkcs1_sha256(0x0401),
        rsa_pkcs1_sha384(0x0501),
        rsa_pkcs1_sha512(0x0601),

        /* ECDSA algorithms */
        ecdsa_secp256r1_sha256(0x0403),
        ecdsa_secp384r1_sha384(0x0503),
        ecdsa_secp521r1_sha512(0x0603),

        /* RSASSA-PSS algorithms */
        rsa_pss_sha256(0x0804),
        rsa_pss_sha384(0x0805),
        rsa_pss_sha512(0x0806),

        /* EdDSA algorithms */
        ed25519(0x0807),
        ed448(0x0808),

        /* Legacy algorithms */
        rsa_pkcs1_sha1(0x0201),
        ecdsa_sha1(0x0203),

        /* Reserved Code Points */
        private_use(0xFE00..0xFFFF),
        (0xFFFF)
    } SignatureScheme;

    struct {
        SignatureScheme supported_signature_algorithms<2..2^16-2>;
    } SignatureSchemeList;

注意:このenumは、TLS 1.2にある"SignatureAlgorithm"拡張を置き換えるもの
であるため、"SignatureScheme"と名付けられています。このRFC上では、
"署名アルゴリズム"として記載します。

各SignatureSchemeの値は、クライアントが検証しようとする署名アルゴリズ
ムのリストです。値は優先度の順番で通知されます。署名アルゴリズムはダイ
ジェストからではなく、任意の長さのメッセージから生成される点に留意して
ください。従来のダイジェストによるアルゴリズムは、特定のハッシュアルゴ
リズムを入力とする最初のハッシュと、処理を継続することを、TLS上に定義
されるべきです。上記のコードポイントのグループは、次のような意味を持っ
ています。

 RSASSA-PKCS1-v1_5アルゴリズム
  [SHS]に定義されているハッシュアルゴリズムであるRSASSA-PKCS1-v1_5[RFC8017]
  を利用した署名アルゴリズムを通知します。これらの値は証明書の署名に利
  用  されるだけで、TLSハンドシェイクメッセージの署名に利用することを
  意味していません。

 ECDSAアルゴリズム
  ANSI X9.62[X962]及びFIPS 186-4[DSS]に定義されている曲線と、[SHS]に定
  義されているハッシュアルゴリズムによるECDSA[ECDSA]を使用した署名アル
  ゴリズムを通知します。署名はDERエンコード[X690]のECDSA-Sig-Valueの構
  造をしています。

 RSASSA-PSSアルゴリズム
  MGF1(マスク生成関数1)によるRSASSA-PSS[RFC8017]を利用した署名アルゴリ
  ズムを通知します。マスク生成関数を使用したダイジェストと、署名された
  ダイジェストは[SHS]で定義されたハッシュアルゴリズムです。署名された
  TLSハンドシェイクメッセージを利用する場合、ソルトの長さは、ダイジェ
  ストの出力長と同じにしなければなりません[MUST]。このコードポイントは
  このRFCで新しく規定されたものですが、TLS 1.2に対しても適用するように
  定義されています。

 EdDSAアルゴリズム
  [RFC8032]及びその後継で定義されているEdDSAを利用した署名アルゴリズム
  を通知します。これは"PureEdDSA"であり、可変の"prehash"ではないことに
  注意してください。

 Legacyアルゴリズム
  特にSHA1ハッシュを使ったRSASSA-PKCS1-v1_5やECDSAなど、既知の脆弱性が
  知られているため、推奨されなくなったアルゴリズムを通知します。 この
  値は、証明書の署名に利用されるだけであり(Section 4.4.2.2参照)、TLSハ
  ンドシェイクメッセージの署名向けに定義されるものではありません。エン
  ドポイントはこれらのアルゴリズムでネゴシエーションを行うべきではなく
  [SHOULD NOT]、後方互換性のためのみに利用が許されています。クライアン
  トは、これらの値はリストの最も低い優先度として提供しなければなりませ
  ん[MUST](SchemeListに他のすべてのアルゴリズムよりも後に入れます)。
  TLS 1.3サーバは有効な証明書チェインを生成できない場合、このパラメー
  タの通知なしに、SHA-1証明書を提供してはなりません[MUST NOT](Section
   4.4.2.2参照)。

自己証明書やトラストアンカーの証明書は認証のパスの始点となっているため、
それ自身を検証することができません([RFC5280]、Section 3.2を参照)。認証
パスの始点である証明書は"signature_algorithms"拡張でサポートが伝えられ
ていない署名アルゴリズムでも使うことが可能です[MAY]。

TLS 1.2のこの拡張の定義はこれとは異なることに注意してください。TLS 1.3
の実装でTLS 1.2をネゴシエーションしようとする時は、[RFC5246]に要求され
ているように振る舞わなければなりません[MUST]。特に下記のことに留意して
ください。

 - TLS 1.2のClientHelloはこの拡張を無視する可能性があります。

 - TLS 1.2では、この拡張はハッシュと署名のペアになります。ペアは2オク
   テットでエンコードされているため、SignatureSchemeの値はTLS 1.2のエ
   ンコーディングと同じように割り当てられています。一部のレガシーのペ
   アは割り当てられてはいません。これらのアルゴリズムはTLS 1.3では廃止
   されています。どの実装においてもネゴシエーションや、提供を行っては
   なりません[MUST NOT]。特に、MD5[SLOTH]、SHA-224、DSAは使用してはい
   けません[MUST NOT]。

 - ECDSAの署名スキームは、TLS 1.2ではECDSAハッシュと署名のペア担ってい
   ます。しかし、古いセマンティクスは署名に用いる楕円曲線に制約を持っ
   ていません。TLS 1.2でネゴシエーションされている場合、実装は
   "supported_groups"拡張で通知されたどの曲線が利用されても受け付ける
   ようにしなければなりません[MUST]。

 - 実装において、RSASSA-PSS(TLS 1.3では実装が必須)のサポートを通知され
   た場合、TLS 1.2でネゴシエーションされたとしても、そのスキームを使用
   した署名を受け付けるようにしなければなりません[MUST]。TLS 1.2では、
   RSASSA-PSSはRSAの暗号スイートとして使われます。


4.2.4. Certificate Authorities
"certificate_authorities"拡張は、エンドポイントがサポートしている、あ
るいは受信先のエンドポイントが証明書を選択するための指標として利用する
ための、証明書の認証局を通知するために使用されます。

"certificate_authorities"拡張のボディはCertificateAuthoritiesExtension
構造体で構成されています。

    opaque DistinguishedName<1..2^16-1>;

    struct {
        DistinguishedName authorities<3..2^16-1>;
    } CertificateAuthoritiesExtension;

 authorities
  DERエンコード[X690]された、受付可能な認証局のDN[X501]のリストです。
  これらのDNはトラストアンカーか中間CA証明書のDNを指定します。つまり、
  このメッセージは望ましい既知のトラストアンカーを記載するために使用さ
  れます。

クライアントはClientHelloに"certificate_authorities"拡張を入れて送信す
ることができます[MAY]。サーバはCertificateRequestメッセージで送信する
ことができます[MAY]。

サーバの"trusted_ca_keys"拡張は、[RFC6066]と同じ目的で利用しますが、少
し複雑なものとなっており、またTLS 1.3では利用されません(しかしながら、
クライアントが以前のバージョンのTLSを要求する場合は、クライアントの
ClientHelloメッセージに載る場合があります)。


4.2.4.1. OID Filters
"oid_filters"拡張は、サーバがクライアント証明書が必要な場合に、OIDと値
のペアを提供することができます。この拡張は、サーバによって提供された場
合、ただCertificateRequestメッセージを送信しなければなりません。

    struct {
        opaque certificate_extension_oid<1..2^8-1>;
        opaque certificate_extension_values<0..2^16-1>;
    } OIDFilter;

    struct {
        OIDFilter filters<0..2^16-1>;
    } OIDFilterExtension;

 filters
  DERエンコード[X690]フォーマットの許可されている証明書拡張OID[RFC5280]
  のリストです。一部の証明書拡張OIDは複数の値をとります(つまり、
  Extended Key Usageです)。サーバが空ではないフィルタリストを通知した
  場合、クライアント証明書にはクライアントが認識した拡張OIDのすべてを
  応答に含めなければなりません[MUST]。クライアントによって認識された各
  拡張OIDのすべてがクライアント証明書に含まれなければなりません[MUST]
  (ただし証明書が他の値である可能性があります[MAY])。しかし、クライア
  ントは認識できない拡張OIDについては無視し、スキップしなければなりま
  せん[MUST]。クライアントが証明書拡張OIDによって要求されたOIDを無視し、
  要求を満たさない証明書を提供した場合、サーバ自身の裁量によって、クラ
  イアント認証無しで接続を継続するか、"unsupported_certificate"アラー
  トでハンドシェイクを破棄するか選択できます[MAY]。

PKIX RFCは証明書拡張OIDの種類と対応する値を定義します。種類によって、
ビット単位による照会が必要ない場合があります。TLSの実装には、証明書拡
張OIDを利用した証明書の選択を、それぞれのPKIライブラリに依存した動作で
行われることが期待されています。

このドキュメントは、[RFC5280]に定義された2つの標準の証明書拡張による照
会ルールを定義しています。

 - リクエスト内すべてのkey usageビットが、証明書のKey Usage拡張にある
   場合、Key Usage拡張が一致することになります。

 - 証明書のExtended Key Usage拡張は、リクエストの目的のOIDキーがすべて
   Extended Key Usageに見つかった場合でも一致したことになります。リク
   エストに、anyExtendedKeyUsage OIDを使用してはいけません[MUST]。

他の仕では、別の証明書拡張の一致規則を定義している可能性があります。


4.2.5. ハンドシェイク後のクライアント認証
"post_handshake_auth"拡張は、クライアントがハンドシェイク後にSection 4.6.2
の認証処理を行いたいことを通知します。サーバは、クライアントが要求しな
い限り、ハンドシェイク後にCertificateRequestを送信してはなりません[MUST]。
サーバはこの拡張を送信してはなりません[MUST NOT]。

"post_handshake_auth"拡張の"extension_data"フィールドは長さは0です。

4.2.6. Negotiated Groups
クライアントによって送信される、"supported_groups"拡張は、クライアント
がサポートしている鍵交換のグループ名が優先度が高い順に通知します。

注意:TLS 1.3より前のバージョンでは、この拡張は"elliptic_curves"拡張と
呼ばれており楕円曲線のグループのみが含まれていました。詳細は[RFC4492]
および[RFC7919]を参照してください。また、この拡張はECDSAにおける曲線種
類のネゴシエーションにも利用されていました。署名アルゴリズムについては、
独立してネゴシエーションされるようになっています(Section 4.2.3参照)。

この拡張の"extension_data"フィールドは"NamedGroupList"の値です。

    enum {
        /* Elliptic Curve Groups (ECDHE) */
        secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
        x25519(0x001D), x448(0x001E),

        /* Finite Field Groups (DHE) */
        ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096 (0x0102),
        ffdhe6144(0x0103), ffdhe8192(0x0104),

        /* Reserved Code Points */
        ffdhe_private_use(0x01FC..0x01FF),
        ecdhe_private_use(0xFE00..0xFEFF),
        (0xFFFF)
    } NamedGroup;

    struct {
        NamedGroup named_group_list<2..2^16-1>;
    } NamedGroupList;

 Elliptic Curve Groups (ECDHE)
  FISP 186-4[DSS]や[RFC7748]に定義されている、名前付き曲線のサポートを
  通知します。0xFE00から0xFEFFはプライベート利用のための予約領域です。

 Finite Field Groups (DHE)
  [RFC7919]に定義の有限体グループのサポートを通知します。0x01FCから0x01FF
  はプライベート利用のための予約領域です。

named_group_listの要素はクライアントの優先度によって並べられています
(先頭が最優先)。

TLS 1.3では、サーバは"supported_groups"拡張をクライアントに送信するこ
とができます。クライアントは、ハンドシェイクの成立前に"supported_groups"
で見つけた情報で動作してはなりませんが[MUST NOT]、ハンドシェイクの成立
から学習した情報で以降のコネクションの"key_share"拡張に使うグループを
変更することができます。サーバが"key_share"拡張にある一つのグループを
サポートしているが、ClientHelloでまだ受け付けられていない場合、クライ
アントの設定を更新するため、"supported_groups"を送信するべきです[SHOULD]。
この場合、クライアントのサポート状況に関係なく、サーバがサポートしてい
るすべてのグループを拡張に含めるべきです[SHOULD]。


4.2.7. Key Share
"key_share"拡張はエンドポイントの暗号パラメータを格納したものです。

クライアントは空のclient_shareを送信し、追加のラウンドトリップコストを
払い、サーバのグループ選択の要求を見ることがあります。(Section 4.1.4参照)

    struct {
        NamedGroup group;
        opaque key_exchange<1..2^16-1>;
    } KeyShareEntry;

 group
  鍵交換方式の名前グループです。有限体のDiffie-Hellman[DH]パラメータは
  Section 4.2.7.1に、楕円曲線のDiffie-Hellmanは Section 4.2.7.2に記載
  しています。

 key_exchange
  鍵交換の情報です。このフィールドの内容は、それぞれの方式によって決め
  られています。

この拡張の"extension_data"フィールドは次の"KeyShare"を含んでいます。

    struct {
        select (Handshake.msg_type) {
            case client_hello:
                KeyShareEntry client_shares<0..2^16-1>;

            case hello_retry_request:
                NamedGroup selected_group;

            case server_hello:
                KeyShareEntry server_share;
        };
    } KeyShare;

 client_shares
  クライアントの優先度順に並んだ、要求したKeyShareEntryのリストです。
  このベクトルは、クライアントがHelloRetryRequestを要求している場合、
  空になる可能性があります。各KeyShareEntryの値は、"supported_groups"
  拡張で要求されたグループと一致しなければならず[MUST]、同じ順番でなけ
  ればなりません[MUST]。しかし、値は"supported_groups"拡張と完全に同じ
  である必要はなく[MAY]、最も優先しているグループが省略される可能性が
  あります[MAY]。このような状況では、最も優先するグループが新しく、サ
  ポート状況が十分でない場合、前世代の鍵が共有されることが発生し得ます。
  
 selected_group
  サーバがネゴシエーションを行いたいため、ClientHello/KeyShareで再試行
  を要求している、双方でサポートしているグループ。

 server_share
  クライアントのKeyShareEntryの内の、一つのKeyShareEntryの値。

クライアントはKeyShareEntryを複数要求することができ、各々は鍵交換のパ
ラメータのセットです。具体的には、クライアントが共有を要求するいくつか
の楕円曲線または複数のFFDHEグループになります。各KeyShareEntryのkey_exchange
の値は、独立して生成されなければなりません[MUST]。クライアントは複数の
KeyShareEntryの値で同じグループを要求してはいけません[MUST NOT]。クラ
イアントは自身の"supported_groups"にないKeyShareEntryの値を提供しては
いけません[MUST NOT]。また、サーバはこれらのルールのチェックを行い、も
し1つでも違反している場合は"illegal_parameter"アラートによりハンドシェ
イクを破棄する可能性があります[MAY]。

この拡張をHelloRetryRequestで受信した時、クライアントは次の2つについて
検証を行わなければなりません[MUST]。
(1)selected_groupフィールドが提供したClientHelloの"supported_groups"拡
   張に含まれていたものであること。
(2)selected_groupフィールドが提供したClientHelloの"key_share"拡張に含
   まれていないものであること。
もし、いずれかの検証に失敗した場合は、クライアントは"illegal_parameter"
アラートによりハンドシェイクを破棄しなければなりません[MUST]。つまり、
新たなClientHelloを送信した時、クライアントは元の"key_share"拡張を、契
機となったHelloRetryRequestのselected_groupフィールドで通知された、新
しいグループのKeyShareEntryに置き換えなければなりません[MUST]。

(EC)DHE鍵を利用する場合、サーバはServerHelloで一つのKeyShareEntryを要
求します。この値はクライアントによって要求されたKeyShareEntryの内、サ
ーバがネゴシエーションのために選択した値と同じグループでなければなりま
せん[MUST]。サーバは、"supported_groups"拡張で通知されていないKeyShareEntry
を送信してはならず[MUST NOT]、また、PskKeyExchangeModeの"psk_ke"を利用
する時では、KeyShareEntryを送信してはなりません[MUST NOT]。クライアン
トからHelloRetryRequestを受けた場合、クライアントはServerHelloのNamedGroup
で選択されたものがHelloRetryRequestと同じものであるか検証しなければな
りません[MUST]。もし検証に失敗した場合、クライアントは"illegal_parameter"
アラートによりハンドシェイクを破棄しなければなりません[MUST]。


4.2.7.1. Diffie-Hellmanパラメータ
クライアントおよびサーバのDiffie-Hellman[DH]パラメータは、KeyShare中の
KeyShareEntry構造体のkey_exchangeフィールドにopaqueの形式でエンコード
されています。opaque値は特定のグループ(グループの定義については[RFC7919]
を参照)のDiffie-Hellmanの公開鍵(Y = g^X mod p)がビックエンディアンかつ、
左詰めでゼロパディングされた形式で格納されています。

注意:Diffie-Hellmanグループは、公開鍵が同じ長さになるようにパディング
されています。

ピアは互いの公開鍵Yが 1 < Y < p-1 の範囲であることを検査シなければなり
ません[MUST]。このチェックは通信相手の振る舞いと、こちらのシステムを小
さいサブグループに強制させないことを保証するものです。	


4.2.7.2. ECDHEパラメータ
クライアントおよびサーバのECDHEパラメータはネットワークバイトオーダで、
XとYの値をバイナリで表します。これらは内部で長さを記述しておらず、各要
素の長さは曲線のパラメータによって決定されます。P-256では、XおよびYは
32オクテットの長さで、必要であれば左詰めでゼロパディングされます。同じ
く、P-384は48オクテット、P-521は66オクテットになります。

secp256r1、secp384r1、secp521r1の曲線では、ピアは互いの公開鍵Yが、楕円
曲線上の座標であることを検証しなければなりません[MUST]。適切な懸賞手順
は[X962]のSection 4.3.7あるいは[KEYAGREEMENT]のSection 5.6.2.6に定義さ
れています。このプロセスは3つのステップからなります。
(1)Yが無限遠点ではないこと。
(2)Y=(x,y)の距離が正しいものであること。
(3)(x,y)が楕円曲線の解であること。
実装者は、これらの曲線が正しいサブグループに属していることの検証までは
行う必要はありません。

X25519やX448では、公開鍵の値は[RFC7748]に定義されている関数の入力およ
び出力のバイト配列です。X25519は32バイト、X448は56バイトです。

注意:TLS 1.3より前では、座標フォーマットのネゴシエーションが行われてい
ましたが、TLS 1.3ではこの機能は削除され、単一の座標フォーマットになり
ます。


4.2.8. Pre-Shared Key Exchange Mode
PSKを利用する場合、クライアントは"psk_key_exchange_modes"拡張を送信し
なければなりません[MUST]。この拡張の意味として、クライアントがこれらの
方式のPSKのみをサポートし、ClientHelloのPSKの要求とサーバがNewSessionTicket
で提供するものの両方を制限する事になります。

クライアントは、"pre_shared_key"拡張を要求する場合、"psk_key_exchange_modes"
拡張を提供しなければなりません[MUST]。クライアントが"psk_key_exchange_modes"
拡張なしに"pre_shared_key"拡張を要求した場合、サーバはハンドシェイクを
破棄しなければなりません[MUST]。サーバはクライアントのリストにない鍵交
換方式を選択してはいけません[MUST NOT]。この拡張もPSKによるレジューム
の利用を制限します。サーバは通知されている方式と互換性のないチケットに
よるNewSessionTicketを送信すべきではありません[SHOULD NOT]。しかし、も
しサーバがそのような振る舞いを行ったとしても、クライアントへの影響はセ
ッションのレジュームが失敗するのみに留まります。

サーバは"psk_key_exchange_modes"拡張を送信してはなりません[MUST NOT]。

    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

    struct {
        PskKeyExchangeMode ke_modes<1..255>;
    } PskKeyExchangeModes;

 psk_ke
  PSKのみによって鍵を確立する方式です。この方式ではサーバは"key_share"
  値を提供してはいけません[MUST NOT]。

 psk_dhe_ke
  (EC)DHEを用いたPSKにより鍵を確立する方式です。この方式ではクライアン
  トおよびサーバはSection 4.2.7に記載の"key_share"値を提供しなければな
  りません[MUST]。


4.2.9. Early Data Indication
PSKが利用される時、クライアントは最初のメッセージ送信時にアプリケーショ
ンデータを送信することができます。クライアントはこの機能を利用する場合、
"early_data"拡張と共に"pre_shared_key"も提供しなければなりません[MUST]。

この拡張の"extension_data"フィールドは"EarlyDataIndication"値を格納し
ています。

    struct {} Empty;

    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;
            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;

max_early_data_sizeについてはSection 4.6.1を参照してください。

0-RTTデータのパラメータ(対称暗号、ALPNプロトコル等)は、PSKでのネゴシエ
ーションの確立と同様です。early dataの暗号化に使用されるPSKは、クライ
アントの"pre_shared_key"拡張のリストの最初のPSKでなければなりません[MUST]。

NewSessionTicketにより提供されたPSKでは、サーバは選択したPSKのID
(PskIdentity.obfuscated_ticket_ageを2^32でモジュロ演算した結果と
ticket_age_addとの差分によって計算されるもの)の寿命が許容範囲内である
ことを検証しなければなりません[MUST](Section 8参照)。許容範囲内ではな
かった場合、サーバは0-RTTを拒否し、ハンドシェイクを継続するべきで[SHOULD]、
ClientHelloが新しいものであると前提した、他の挙動を行うべきではありま
せん。

最初に送信される0-RTTメッセージは、他の送信のものと同じ暗号化されたコ
ンテントタイプを持っていますが、別の鍵によって暗号化されています。サー
バのFinishメッセージを受信した後、サーバがearly dataを受け付けている場
合、鍵交換を通知するためにEndOfEarlyDataメッセージが送信されます。この
メッセージは0-RTTの鍵によって暗号化されています。

"early_data"拡張を受信したサーバは、次の3つから1つの振る舞いを行わなけ
ればなりません[MUST]。

 - 拡張を無視し、正規の1-RTTの応答を行う。サーバは受信したearly dataの
   レコードの復号を無視した時、正規の1-RTTハンドシェイクを完了するまで、
   レコードの復号失敗をmax_early_data_sizeまでスキップすることができま
   す。

 - クライアントに対して、別のClientHelloをHelloRetryRequestにより要求
   します。クライアントはこのHelloRetryRequestに対するClientHelloに
   "early_data"拡張を含めてはいけません[MUST]。サーバは"application_data"
   タイプの他のコンテントタイプのすべてのレコード(暗号化されて通知され
   ます)をスキップすることで、early dataを無視します。

 - EncryptedExtensionsにこの拡張を返却し、early dataによる通信を行うこ
   とを通知します。サーバはearly dataメッセージを部分的に受け取ること
   はできません。サーバがearly dataを受け入れるメッセージを生成して送
   信した時点で、early dataメッセージがすでに送信済みである可能性があ
   ります。

early dataを受け入れるためには、サーバはPSKの暗号スイートを受け付け、
クライアントの"pre_shared_key"拡張の要求を選択しなければなりません[MUST]。
加えて、チケットが確立している間に、次の値がネゴシエーションと矛盾がな
いことを検証しなければなりません[MUST]。

 - TLSバージョンと暗号スイート

 - もしある場合、選択されたALPNプロトコル[RFC7301]

さらに拡張が0-RTT間で定義されている必要があります[MUST]。

これらのチェックが失敗した場合、サーバは拡張を返してはならず[MUST NOT]、
前述されているの2つのメカニズムのどちらかによる最初のフライトデータを
すべて破棄しなければなりません(つまり1-RTTまたは2-RTTにフェイルバック
します)。クライアントが0-RTTハンドシェイクを試み、サーバが拒否した場合、
サーバは通常0-RTTレコード保護鍵を持っておらず、最初の0-RTT以外のメッセ
ージを見つけるために、復号を試みます(1-RTTハンドシェイク鍵を使用するか、
HelloRetryRequestのケースでの平文のClientHelloを探します)

サーバが"early_data"拡張を受け入れることを選択した場合、early dataレコ
ードのエラーハンドリングにおいて同じ挙動を行うことが要求されます。特に、
サーバが"early_data"拡張後の0-RTTレコードの復号に失敗した場合、Section 5.2
にあるように、"bad_record_mac"アラートによりコネクションを終了しなけれ
ばなりません[MUST]。

サーバが"early_data"拡張を拒否した場合、クライアントアプリケーションは
ハンドシェイクの完了後にearly dataの再送を選択することができます[MAY]。
自動的にearly dataを再送するとコネクション状態が正しくない可能性がある
ことに注意してください。例えば、early dataを使った時と別のALPNプロトコ
ルをネゴシエーションで選択している時、アプリケーションは異なる
メッセージを構築する必要があります。同じように、early dataとコネクショ
ンの状態により、ハンドシェイクの完了後にエラーが送信される可能性があり
ます。

TLSの実装は自動的にearly dataを再送するべきではありません[SHOULD NOT]。
アプリケーション自身により、再送すべきか決定します。TLSの実装は同じALPN
プロトコルを選択したコネクション出ない限り、自動的にearly dataを再送し
てはなりません[MUST NOT]。


4.2.10. Pre-Shared Key Extension
"pre_shared_key"拡張は、PSK鍵の確立のためのハンドシェイクに利用する事
前共有鍵を通知するために使用されます。

この拡張の"extension_data"フィールドは"PreSharedKeyExtension"値を格納
しています。

    struct {
        opaque identity<1..2^16-1>;
        uint32 obfuscated_ticket_age;
    } PskIdentity;

    opaque PskBinderEntry<32..255>;

    struct {
        select (Handshake.msg_type) {
            case client_hello:
                PskIdentity identities<7..2^16-1>;
                PskBinderEntry binders<33..2^16-1>;

            case server_hello:
                uint16 selected_identity;
        };

    } PreSharedKeyExtension;


 identity
  キーのラベルです。例として、Appendix B.3.4に定義されているチケットや、
  外部で確立した事前共有鍵のラベルになります。

 obfuscated_ticket_age
  難読化された鍵の寿命です。Section 4.2.10.1に、NewSessionTicketメッセ
  ージを通して同一性を確認するための、この値の形式について述べられてい
  ます。外部で確立されたものについては、0が使われるべきで[SHOULD]、サ
  ーバは値を無視しなければなりません[MUST]。

 identities
  クライアントがサーバとのネゴシエーションで用いるIDのリストです。
  "early_data"拡張(Section 4.2.9参照)に付随して送信される場合、最初のID
  が0-RTTデータに利用されます。

 binders
  "pre_shared_keys"拡張によって要求された各PSKのHMAC値のセットで、要求
  されたものと同じ順番で並んでいます。計算方法は以降に記述します。

 selected_identity
  クライアントのリストからサーバが選択したIDのインデックスです(0から開
  始されます)。

各PSKは単一のハッシュアルゴリズムに関連しています。チケットメカニズム
(Section 4.6.1)によって確立されたPSKは、チケットが確立されたコネクショ
ンのKDFハッシュアルゴリズムです。外部によって確立されたPSKは、ハッシュ
アルゴリズムをPSKが確立された時に設定するか、ハッシュアルゴリズムが定
義されない場合は、デフォルトのSHA-256に設定されなければなりません[MUST]。
サーバは、選択したPSK(あれば)と暗号スイートに矛盾がないことを保証しな
ければなりません。

実装者の注意:PSK/cipherの暗号スイートのマッチング要求の実装で最も率直
な方法は、暗号スイートを最初にネゴシエートし、互換性のないPSKを排除す
ることです。どのような不明なPSKも(つまり、PSKデータベースにない、また
は不明な鍵によって暗号化されている)、単純に無視されるべきです[SHOULD]。
受け付けられないPSKが見つかった場合、サーバは可能であれば非PSKのハンド
シェイクを行うべきです[SHOULD]。

PSK鍵の確立を受け付ける前に、サーバはbinder値との一致を検証しなければ
なりません[MUST](Section 4.2.10.2以降を参照)。この値がない、または有効
ではない場合、サーバはハンドシェイクを破棄しなければなりません[MUST]。
サーバは複数のbinderでの検証はすべきではありません[SHOULD NOT]。むしろ、
単一のPSKを選択し、PSKに合った単独のbinderを検証すべきです[SHOULD]。
PSK鍵の確立を受け付けた時、サーバは選択したIDを"pre_shared_key"拡張で
通知します。

クライアントは、サーバのselected_identityが提供した範囲のものであるこ
と、サーバが選択した暗号スイートに関連したPSKのハッシュが通知されてい
ること、ClientHelloの"psk_key_exchange_modes"で要求された場合、サーバ
の"key_share"拡張があること、を確認しなければなりません[MUST]。これら
の値に矛盾がある場合、クライアントは"illegal_parameter"アラートにより
ハンドシェイクを破棄しなければなりません[MUST]。

サーバが"early_data"拡張を提供している場合、クライアントはサーバの
selected_identityが0であることを検証しなければなりません[MUST]。0以外
の値であった場合、クライアントは"illegal_parameter"アラートによりハン
ドシェイクを破棄しなければなりません[MUST]。

この拡張はClientHelloの最後尾になければなりません[MUST](これは後述にあ
るように、実装を容易にするためのものです)。サーバは拡張の最後尾である
ことをチェックしなければならず[MUST]、最後尾ではなかった場合、
"illegal_parameter"アラートによりハンドシェイクを破棄しなければなりま
せん[MUST]。


4.2.10.1. Ticket Age
クライアントにおいて、チケットの寿命はNewSessionTicketメッセージを受信
してからの時間になります。クライアントは"ticket_lifetime"を超えたチケ
ットを利用してはなりません[MUST NOT]。PskIdentityの"obfuscated_ticket_age"
フィールドは、ミリ秒の寿命にチケットに含まれた"ticket_age_add"値を加算
した形式の難読化されたチケットの寿命を格納しています。2^32のモジュロ演
算についてはSection 4.6.1を参照してください。この加算は観測者がチケッ
ト無しにコネクションの再利用を行うことを妨害します。NewSessionTicketメ
ッセージの"ticket_lifetime"フィールドは秒単位ですが、"obfuscated_ticket_age"
はミリ秒ということに注意してください。これは、チケットの寿命が1週間に
制限されているため、ミリ秒でも32bitで十分です。


4.2.10.2. PSK Binder
PSK binder値は、PSKが生成されたハンドシェイク(NewSessionTicketメッセー
ジによる場合)とそれが利用されたハンドシェイク間と同様に、PSKと現在のハ
ンドシェイク間に関連づいて形成されます。binderリストの各エントリは
ClientHelloからPreSharedKeyExtension.identitiesフィールドまでの部分を
ハッシュとしたHMACを計算したものです。これは、ClientHelloのすべてを含
んだものですが、binderリスト自身は含まれていません。メッセージの長さの
フィールド(全体長、拡張ブロック長、"pre_shared_key"拡張の長さ)はbinder
がすべて存在するとして決定されます。

PskBinderEntryはFinishメッセージ(Section 4.4.4)と同様の方法で計算され
ますが、binder_keyであるBaseKeyは、要求されたPSKに一致するキースケジュ
ールにより導出されます(Section 7.1参照)。

ハンドシェイクがHelloRetryRequestを含んでいる場合、初回のClientHelloと
HelloRetryRequestは新しいClientHelloの複写を含んでいます。例えば、クラ
イアントがClientHello1を送信した場合、このbinderは次のように計算されま
す。

    Transcript-Hash(ClientHello1[truncated])

サーバがHelloRetryRequestを応答し、クライアントがClientHello2を送信し
た場合、このbinderは次のように計算されます。

    Transcript-Hash(ClientHello1,
                    HelloRetryRequest,
                    ClientHello2[truncated])

ClientHello1の全てが、他のハンドシェイクのハッシュ計算に含まれることに
なります。初回フライトでは、ClientHello1[truncated]のハッシュが直接利
用されますが、2回目のフライトでは、Section 4.4.1にあるように、
ClientHello1が"handshake_hash"メッセージとして再演算されます。


4.2.10.3. 処理順番
クライアントはサーバのFinishを受け取るまで、0-RTTデータの"stream"が許
可されており、ハンドシェイクの切れ目で、EndOfEarlyDataメッセージを送信
します。デッドロックを避けるため、"early_data"を受け取った時は、サーバ
はクライアントのClientHelloを受信後、クライアントからのEndOfEarlyData
を待つのではなく、即時にServerHelloを送信しなければなりません[MUST]。


4.3. サーバパラメータ
EncryptedExtensionsおよびCertificateRequestの2つのサーバからのメッセー
ジは、ハンドシェイクの停止の情報を含んでいます。これらのメッセージは、
server_handshake_traffic_secretによって導出された鍵によって暗号化され
ています。


4.3.1. Encrypted Extensions
すべてのハンドシェイクにおいて、サーバはServerHelloメッセージの後から
EncryptedExtensionsメッセージを送信しなければなりません[MUST]。これが
server_handshake_traffic_secretによって導出された鍵で暗号化された最初
のメッセージになります。

EncryptedExtensionsメッセージは保護されている拡張を含んでいます。つま
り、暗号文を確立するためには必要ないものではありますが、個別の証明書と
は関連付けられてはいないものです。クライアントは受け取ったEncryptedExtensions
が禁止されている拡張でないことをチェックしなければならず[MUST]、禁止さ
れている拡張を見つけた場合、"illegal_parameter"アラートによりハンドシェ
イクを破棄しなければなりません。

EncryptedExtensionsメッセージの構造:

    struct {
        Extension extensions<0..2^16-1>;
    } EncryptedExtensions;

 extensions
  拡張のリスト。詳細はSection 4.2の表を参照してください。


4.3.2. Certificate Request
クライアントを認証しようとするサーバは、クライアントからの証明書を要求
することができます[MAY]。このメッセージを送信する場合、EncryptedExtensions
の後に送信しなければなりません[MUST]。

CertificateRequestメッセージの構造:

    struct {
        opaque certificate_request_context<0..2^8-1>;
        Extension extensions<2..2^16-1>;
    } CertificateRequest;

 certificate_request_context
  証明書要求および、クライアントからのCertificateメッセージの応答を識
  別するための  opaque配列形式のデータ。certificate_request_contextは
  コネクションのスコープ内でユニークでなければなりません[MUST](クライ
  アントのCertificateVerifyメッセージのリプレイ攻撃  を防ぐためのもの
  です)。このフィールドは、Section 4.6.2にあるハンドシェイク後の認証を
  行わない場合は長さが0になります[SHALL]。ハンドシェイク後の認証を要求
  している時、サーバは、攻撃者がクライアントのCertificateVerifyメッセ
  ージを事前に計算して算出したクライアントの一時鍵を持つことを防止する
  ため、クライアントが予測できないコンテキスト(つまりランダムに生成し
  たもの)を作るべきです[SHOULD]。

 extensions
  要求された証明書のパラメータを記載した拡張のセットです。"signature_algorithms"
  拡張は必ず記載しなければならず[MUST]、他の拡張はこのメッセージが定義
  される場合に選択的に含まれています。クライアントは解釈できない拡張に
  ついては無視しなければなりません[MUST]。

以前のバージョンのTLSにおいて、CertificateRequestメッセージは、署名ア
ルゴリズムのリストとサーバが受け付けるCA局を伝えるものでした。TLS 1.3
では、前者は"signature_algorithms"拡張によって送信されるようになってお
り、後者は"certificate_authorities"拡張(Section 4.2.4参照)によって送信
されます。

PSKで認証を行うサーバは、メインのハンドシェイクにおいてCertificateRequest
メッセージを送信してはならないため[MUST NOT]、クライアントが提供した
"post_handshake_auth"拡張(Section4.2.5参照)によるハンドシェイク後の認
証でCertificateRequestメッセージを送信することができます[MAY]。


4.4. 認証メッセージ
Section 2で論じたように、TLSは通常、認証・鍵の確認・ハンドシェイクの完
了のための共通のメッセージセット(Certificate・CertificateVerify・Finish)
を使用します(PreSharedKeyのbinderもまた同じように鍵の確認を行います)。
これらの3つのメッセージは、いつもハンドシェイクの最後のメッセージとし
て送信されます。CertificateおよびCertificateVerifyメッセージは後述で定
義されるように、特定の状況下でのみ送信されます。Finishedメッセージは必
ず認証ブロックの最後として送信されます。これらのメッセージは
[sender]_handshake_traffic_secretから導出される鍵で暗号化されています。

Authenticationメッセージの計算は、すべて一律に次の入力によって算出され
ます。

 - 証明書および署名に利用される鍵

 - 複写ハッシュに含まれているメッセージセットで構成されるハンドシェイ
   クのコンテキスト

 - MAC鍵の計算に使用されるベース鍵

これらの入力で、次のメッセージが構成されます。

 Certificate
  認証に利用される証明書および、証明書チェインでサポートされている証明
  書。証明書に基づいたクライアント認証は0-RTTモードではないことに注意
  してください。

 CertificateVerify
  複写ハッシュ(ハンドシェイクコンテキスト、Certificate)によるシグネチャ。

 Finished
  ベース鍵により導出したMAC鍵を利用した、複写ハッシュ(ハンドシェイクコ
  ンテキスト、Certificate、CertificateVerify)によるMAC。

次の表は各シナリオにおけるハンドシェイクコンテキストとMAC Base Keyを定
義したものです。


   +-----------+----------------------------+--------------------------+
   | Mode      | Handshake Context          | Base Key                 |
   +-----------+----------------------------+--------------------------+
   | Server    | ClientHello ... later of E | server_handshake_traffic |
   |           | ncryptedExtensions/Certifi | _secret                  |
   |           | cateRequest                |                          |
   |           |                            |                          |
   | Client    | ClientHello ... later of   | client_handshake_traffic |
   |           | server                     | _secret                  |
   |           | Finished/EndOfEarlyData    |                          |
   |           |                            |                          |
   | Post-     | ClientHello ... client     | client_application_traff |
   | Handshake | Finished +                 | ic_secret_N              |
   |           | CertificateRequest         |                          |
   +-----------+----------------------------+--------------------------+


4.4.1. 複写ハッシュ
TLSの多くの暗号演算では、複写ハッシュ(transcript hash)の使用しています。
この値は、各ハンドシェイクメッセージ、ハンドシェイクメッセージヘッダ、
ハンドシェイクメッセージタイプ、フィールド長を連結したもの(レコードレ
イヤーのヘッダは含めません)からハッシュを計算したものです。
つまり、

    Transcript-Hash(M1, M2, ... MN) = Hash(M1 || M2 ... MN)

通常のルールの例外として、サーバがHelloRetryRequestに対するClientHello
を応答した時、ClientHello1はHash(ClientHello1)を含んだ、"message_hash"
タイプの特殊なハンドシェイクメッセージに置き換わります。

    Transcript-Hash(ClientHello1, HelloRetryRequest, ... MN) =
        Hash(message_hash ||        // Handshake type
             00 00 Hash.length ||   // Handshake message length
             Hash(ClientHello1) ||  // Hash of ClientHello1
             HelloRetryRequest ... MN)

この構造の理由は、中間ハッシュの状態全体(Section 4.2.2参照)のエクスポ
ートを要求するのではなく、サーバがcookieにClientHello1のハッシュのみを
入れたステートレスなHelloRetryRequestを行えるようにするためです。

具体的に、複写ハッシュは毎回、ClientHelloから始まる次の送信したメッセ
ージ(ClientHello、HelloRetryRequest、server CertififateRequest、
server Certificate、server Certificate、server CertificateVerify、
server Finished EndOyDarlyData、client Certificate、client CertificateVerify
client Finish)ハンドシェイクメッセージのシーケンスから計算されます。

一般的に実装はネゴシエーションハッシュに基づいた複写ハッシュを行いなが
ら、複写を行うことができます。しかしながら、ハンドシェイク後の認証を行
った場合は、ハンドシェイクの終わりまでのメッセージのみとなることに注意
してください。


4.4.2. Certificate
このメッセージはピアにエンドポイントの証明書チェインを送るものです。

サーバは鍵交換で認証に証明書を利用する方式の時は、Certificateメッセー
ジを送信しなければなりません[MUST](このドキュメンにおいてPSKを除くすべ
ての鍵交換方式がこの方式です)。

クライアントはサーバがCertificateRequestメッセージ(Section 4.3.2)によ
ってクライアント認証を要求してきた場合に限り、Certificateメッセージを
送信しなければなりません[MUST]。サーバがクライアント認証を要求したが合
う証明書を所持していない場合、クライアントは証明書を含まないCertificate
メッセージを送信しなければなりません[MUST](つまり、"certificate_list"
フィールド長が0になります)。

Certificateメッセージの構造:

    struct {
        select(certificate_type){
            case RawPublicKey:
              // From RFC 7250 ASN.1_subjectPublicKeyInfo
              opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

            case X509:
              opaque cert_data<1..2^24-1>;
        };
        Extension extensions<0..2^16-1>;
    } CertificateEntry;

    struct {
        opaque certificate_request_context<0..2^8-1>;
        CertificateEntry certificate_list<0..2^24-1>;
    } Certificate;

 certificate_request_context
  CertificateRequestに対する応答をこのメッセージで行う場合、Certificate
  メッセージの値は、certificate_request_contextになります。他の場合(サ
  ーバ認証のケースでは)、このフィールドは0になります[SHALL]。

 certificate_list
  CertificateEntry構造体のチェインです。各要素は、一つの証明書と拡張の
  セットが含まれています。

 extensions
  CertificateEnctryの拡張のセットです。"Extension"フォーマットは
  Section 4.2に定義されています。有効な拡張は、OCSP Status拡張([RFC6066]
  および[RFC6961])とSignedCertificateTimestamps([RFC6962])です。拡張は、
  初回ハンドシェイクにあるClientHello拡張に対応する、Certificateメッセ
  ージ内になければなりません[MUST]。拡張をチェイン全体に適用する場合、
  最初のCertificateEntryに含まれているべきです[SHOULD]。

一致する証明書タイプの拡張が使われていない("server_certificate_type"ま
たは"client_certificate_type")、またはX.509形式の証明書でネゴシエーショ
ンされた場合、各CertificateEntryはX.509証明書が格納されます。送信者の
証明書はリストの最初のCertificateEntryで来なければなりません[MUST]。続
く各証明書は一つ前のものを直接証明するものであるべきです[SHOULD]。これ
は、証明書の検証は各トラストアンカーが独立して配信されて行うことが要求
されているため、サポートしているピアから提供された証明書が省略された証
明書であるとわかっている場合、特定のトラストアンカーの証明書はチェイン
から省略される場合があります[MAY]。

注意:TLS 1.3より前では、"certificate_list"の順序は直前の証明書を証明す
ることが要求されていました。しかし、一部の実装では順序を入れ替えること
もありました。サーバは過渡的な移行のために現在のものと推奨されないもの
の両方を送信することもありますが、この他の場合は単純な設定の誤りです。
互換性を高めるため、すべての実装はチェインとは関係ない証明書の処理や、
どのTLSバージョンの順序のものでも扱えるようにすべきです[SHOULD]。ただ
し、エンドエンティティ証明書だけはチェインの最初になければなりません[MUST]。

RawPublicKeyタイプの証明書がネゴシエーションされた場合、certificate_list
は[RFC7250]のSection 3に定義されている、ASN1_subjectPublicKeyInfoを持
つCertificateEntyを一つのみしか含んではなりません[MUST]。

[RFC6091]のOpenPGPタイプの証明書はTLS 1.3では使用してはなりません[MUST NOT]。

サーバのcertificate_listは必ず空ではないものでなければなりません[MUST]。
クライアントは、サーバの認証要求に対する応答の証明書について、適合する
証明書を所持していない場合は、空のcertificate_listを送信します。


4.4.2.1. OCSP Status および SCT Extensions
[RFC6066]および[RFC6961]はサーバがOCSP応答をクライアントとネゴシエーショ
ンするための拡張を提供しています。TLS 1.2およびそれ以前では、サーバは
この拡張の対応の通知に空の拡張を応答し、OCSP情報はCertificateStatusメ
ッセージで伝えていました。TLS 1.3では、サーバのOCSP情報は、関連する証
明書を含んだCertificateEntryの拡張によって伝えます。具体的に、サーバの
"status_request"拡張のボディ部は[RFC6960]の定義として解釈される、[RFC6066]
で定義のCertificateStatus構造体でなければなりません[MUST]。

同様に、[RFC6962]はTLS 1.2以前でサーバがServerHelloの拡張として、
Signed Certificate Timestamp(SCT)を送信するメカニズムを提供しています。
TLS 1.3では、サーバのSCT情報はCertificateEntry拡張で伝えられます。


4.4.2.2. サーバ証明書の選択
次の規則によって、サーバから証明書が送信されます。

 - 証明書のタイプは、明示的に折衝が行われない限り([RFC7250]によるもの)、
   X.509v3 [RFC5280]でなければなりません[MUST]。

 - サーバのエンドエンティティ証明書の公開鍵(および関連する制限)は、選
   択された認証アルゴリズムに合うものでなければなりません[MUST](現状は、
   RSA、ECDSAまたはEdDSA)。

 - 証明書は、クライアントの"sigunature_algorithms"拡張で通知された署名
   方式で署名された鍵(つまり、デジタル署名ビットはKey Usage拡張がある
   場合、設定されなければなりません)を受け付けなければなりません。

 - "server_name"および"certificate_authorities"拡張[RFC6066]は証明書の
   選択に利用されます。サーバが"server_name"拡張を要求する場合があるた
   め、クライアントは可能であれば、この拡張を送信すべきです[SHOULD]。

サーバによって提供されたすべて証明書は、証明書チェインを提供できる場合、
クライアントが提供した"signature_algorithms"拡張にある署名アルゴリズム
によって署名されていなければなりません[MUST](Section 4.2.3参照)。自己
証明書あるいは、信頼するトラストアンカーの証明書はチェインの一部として
認証されず、どのアルゴリズムでも署名されている可能性があります。

サーバが通知したサポートしているアルゴリズムのみの証明書チェインを提供
できない場合、クライアントがサポートしているか不明な証明アルゴリズムを
含んでいるかもしれない証明書チェインをクライアントへ送信し、ハンドシェ
イクを継続すべきです[SHOULD]。このフォールバックチェインでは、通常SHA-1
ハッシュアルゴリズムを含めるべきではありませんが[SHOULD NOT]、
"signature_algorithms"拡張によってクライアントから許可されている場合は
行ってもよく[MAY]、それ以外は行ってはなりません[MUST]。

クライアントは、提供された証明書のチェインを構築できない場合やハンドシェ
イクを破棄することを決めた場合は、証明書に関連したアラート(デフォルト
では、"unsupported_certificate";Section 6.2等を参照)によってハンドシェ
イクを破棄しなければなりません。

サーバが複数の証明書を持っている場合、上記の基準で一つの証明書を選択し
ます(他の基準としては、TCPレイヤーのエンドポイントのローカル設定があり
ます)


4.4.2.3. クライアント証明書の選択
次の規則によって、クライアントから証明書が送信されます。

 - 証明書のタイプは、明示的に折衝が行われない限り([RFC7250]によるもの)、
   X.509v3 [RFC5280]でなければなりません[MUST]。

 - CertificateRequestメッセージに"certificate_authorities"拡張がある場
   合、証明書チェインの少なくとも一つの証明書は、CAリストの内のいずれ
   かから発行されたものであるべきです[SHOULD]。

 - Section 4.3.2にあるように、証明書は受付可能な署名アルゴリズムで署名
   されなければなりません[MUST]。証明書の署名アルゴリズムに関する規制
   の緩和は、前のバージョンのTLSに見られるもののため注意してください。

 - 空ではない"oid_filters"拡張を含むCertificateRequestメッセージの場合、
   エンドエンティティ証明書はSection 4.2.4.1にあるように、クライアント
   によって認識される拡張OIDと一致しなければなりません[MUST]。

サーバ証明書では、現在のTLSでは使えないアルゴリズムの組み合わせが利用
されるものがあることに注意してください。


4.4.2.4. Certificateメッセージの受信
通常、証明書の検証処理についてはTLSのスコープ外です([RFC5280]参照)。こ
のセクションでは、TLS特有のものについて提供します。

サーバが空のCertificateメッセージを提供した場合、クライアントは
"decode_error"アラートによりハンドシェイクを破棄しなければなりません[MUST]。

クライアントが証明書を送信してこない場合、サーバはクライアント認証なし
にハンドシェイクを継続するか、"certificate_require"アラートによりハン
ドシェイクを破棄するかを選択します[MAY]。証明書チェインが受け付けられ
ない場合(つまり、信頼するCAに署名されたものでない場合))もまた、サーバ
はハンドシェイクを継続するか(クライアントは認証されてないとされます)、
ハンドシェイクを破棄します。

MD5ハッシュの署名が利用された証明書を受信したどのエンドポイントも、
"bad_certificate"アラートによりハンドシェイクを破棄しなければなりませ
ん[MUST]。SHA-1は廃止予定であり、SHA-1を使用している証明書を受信したエ
ンドポイントは、"bad_certificate"アラートによりハンドシェイクを破棄す
ることが推奨されます[RECOMMENDED]。明確に記述すると、エンドポイントが
自己証明書あるいはトラストアンカーの証明書の場合は、受け付けても構わな
いことを意味しています[MAY]。

すべてのエンドポイントは、SHA-256へ移行するか、相互運用を維持しつつ可
能な限り早くSHA-1サポートを廃止していくことが推奨されます[RECOMMENDED]。

証明書の鍵の署名アルゴリズムとは、異なる署名アルゴリズムで署名されてい
る可能性があることに注してください[MAY](例えば、ECDSA鍵で署名されたRSA
鍵など)。


4.4.3. Certificate Verify
このメッセージは、証明書の秘密鍵が正しいものであることを明示的に証明す
るために利用されます。CertificateVerifyメッセージは、それまでのハンド
シェイクの整合性を提供します。サーバは証明書の認証する際、このメッセー
ジを送信しなければなりません[MUST]。クライアントは証明書の認証する際は
このメッセージを送信しなければなりません[MUST](つまり、空ではない
Certificateメッセージの場合)。送信する時は、このメッセージはCertificate
メッセージの直後になければならず、またFinishedメッセージの直前になけれ
ばなりません[MUST]。

Certificateメッセージの構造:

    struct {
        SignatureScheme algorithm;
        opaque signature<0..2^16-1>;
    } CertificateVerify;

algorithmフィールドは、特定の署名アルゴリズムが使用されます(フィールド
の定義についてはSection 4.2.3を参照)。署名はそのアルゴリズムを使用した
デジタル署名です。署名が行われるコンテントはSection 4.4に記載されてい
るハッシュです。

    Transcript-Hash(Handshake Context, Certificate)

デジタル署名は下記を連結したものから計算されます。

 - 64個の32(0x20)で構成された配列

 - コンテキストの配列

 - セパレータとする一つの0バイト

 - 署名されたコンテント

この構造は前TLSバージョンのServerKeyExchangeフォーマットの32バイトプレ
フィックス(ClientHello.random)選択攻撃による署名メッセージを得る攻撃を
防御する意図があります。初期の64バイトパディングはサーバにコントロール
されたServerHello.randomのプレフィクスをクリアします。

サーバ署名のコンテキストの配列は"TLS 1.3, server CertificateVerify"で
あり、クライアントの署名のコンテキストの配列は"TLS 1.3, client CertificateVerify"
です。これは、別のコンテキストでの署名を分離し、クロスプロトコルの潜在
的な攻撃を防ぎます。

例えば、複写ハッシュが32バイトの01である場合(この長さはSHA-256の場合に
生成されるものです)デジタル署名されるサーバのCertificateVerifyのコンテ
ントは、次のようになります。

    2020202020202020202020202020202020202020202020202020202020202020
    2020202020202020202020202020202020202020202020202020202020202020
    544c5320312e332c207365727665722043657274696669636174655665726966
    79
    00
    0101010101010101010101010101010101010101010101010101010101010101

サーバ側では、CertificateVerifyメッセージのsignatureフィールドの計算の
入力は、次のものです。

 - 署名されたコンテント

 - 送信した証明書の署名の秘密鍵

サーバからCertificateVerifyメッセージが送信された場合、署名アルゴリズ
ムはサポートされてないアルゴリズムの証明書チェインしか有効なものがない
以外は、クライアントの"signature_algorithms"拡張で提供された内の一つの
ものでなければなりません[MUST](Section 4.2.3参照)。

クライアントによってCertificateVerifyメッセージが送信された場合、署名
アルゴリズムはCertificateRequestメッセージの"signature_algorithms"拡張
のsupported_signature_algorithmsフィールドにある内の一つのものを使用し
なければなりません[MUST]。

加えて、署名アルゴリズムはサーバのエンドエンティティ証明書の鍵と合うも
のでなければなりません[MUST]。RSA署名は"signature_algorithms"に
RSASSA-PKCS1-v1_5のアルゴリズムのあるなしに関わらず、RSASSA-PSSアルゴ
リズムで利用しなければなりません[MUST]。SHA-1アルゴリズムは、
CertificateVerifyメッセージの署名として使ってはなりません[MUST NOT]。
この仕様において、すべてのSHA-1署名アルゴリズムは、レガシーの証明書と
して定義され、CertificateVerifyの署名としては有効なものではありません。

CertificateVerifyメッセージの受信者は、signatureフィールドを検証しなけ
ればなりません[MUST]。検証に利用する入力は、次のものになります。

 - 署名されたコンテント

 - 関連するCertificateメッセージのエンドエンティティ証明書の公開鍵

 - 受信したCertificateVerifyメッセージのsignatureフィールドのデジタル
   署名

検証が失敗した場合、受信者は"decrypt_error"アラートによりハンドシェイ
クを破棄しなければなりません[MUST]。


4.4.4. Finished
Finishedメッセージは認証ブロックの最後のメッセージです。このメッセージ
はハンドシェイクと鍵の計算の認証を提供するために必須のものです。

Finishedメッセージの受信者は、その内容が正しいことを検証しなければなら
ず[MUST]、正しくない場合は"decrypt_error"アラートによりコネクションを
終了しなければなりません[MUST]。

一方のサイドからFinishedメッセージが送信され、ピア側でFinishedメッセー
ジの受信と検証が行われると、コネクション間でアプリケーションデータの送
受信が開始されます。ピア側のFinished前にデータの送信を行える場合は、次
の2通りあります。

 1.クライアントがSection 4.2.9にある0-RTTデータを送信し終えていること。

 2.サーバは最初のネゴシエーションパケット送信後にデータを送信する場合
   がありますが、ハンドシェイクが完了していないためピア側の同一性も生
   存も保証されていません(つまりClientHelloが再送される可能性がありま
   す)。

Finishedメッセージの演算で使用する鍵は、Section 4.4で定義されている
HKDF(Section 7.1を参照)によるBase鍵から計算されます。
詳細は次のとおりです。

    finished_key =
        HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)

Finishedメッセージ構造:

    struct {
        opaque verify_data[Hash.length];
    } Finished;

verify_data値は次のように計算されます。

    verify_data =
        HMAC(finished_key,
             Transcript-Hash(Handshake Context,
                             Certificate*, CertificateVerify*))

    * 存在する場合のみ含みます。

HMAC[RFC2104]はハンドシェイクのハッシュアルゴリズムを使用します。上記
にあるように、HMACは通常実行時のハッシュによって実装されます。つまり、
計算時点でのハンドシェイクのハッシュです。

以前のTLSバージョンでは、verify_dataは必ず12オクテット長でした。TLS 1.3
では、HMACのハッシュの出力長はハンドシェイクのハッシュのサイズです。

注意:アラートおよびハンドシェイクメッセージ以外のレコードタイプは、ハ
ッシュ計算の入力に含まれません。

1-RTT Finishedメッセージ後のいかなるレコードも、Section 7.2の適切な
application traffic keyによって暗号化されなければなりません[MUST]。特
に、クライアントのCertificateやCertificateVerifyメッセージに対する、
サーバの応答のアラートも含まれます。


4.5. End of Early Data

    struct {} EndOfEarlyData;

サーバが"early_data"拡張を送信した場合、クライアントはサーバのFinished
の受信後に、EndOfEarlyDataメッセージを送信しなければなりません[MUST]。
サーバが"early_data"拡張を送信していない場合、クライアントはEndOfEarlyData
メッセージを送信してはなりません[MUST NOT]。このメッセージはすべての
0-RTTのapplication_dataメッセージを送信したことを通知するものであり、
まだ送信するものがあれば、handshake traffic keysによって保護されたレコ
ードで継続されます。サーバはこのメッセージを送信してはならず[MUST NOT]、
クライアントがこのメッセージを受信した場合は"unexpected_message"アラー
トによってコネクションを終了しなければなりません[MUST]。このメッセージ
はclient_early_traffic_secretにより導出された鍵によって暗号化されてい
ます。


4.6. Post-Handshakeメッセージ
TLSはメインのハンドシェイク後に、他のメッセージも送信することができま
す。これらのメッセージはハンドシェイクのコンテントタイプを使用し、適切
なapplication traffic keyで暗号化されています。


4.6.1. New Session Ticketメッセージ
サーバはクライアントのFinishedメッセージの受信した後のいかなるタイミン
グでも、NewSessionTicketメッセージを送信することができます。このメッセ
ージは、チケットの値と、レジュームされたマスターシークレットから導出さ
れるPSKシークレット間を一意な関連付けを生成します。

クライアントは、ClientHelloの"pre_shared_key"拡張(Section 4.2.10)にチ
ケット値を含めることで、将来的なハンドシェイクでこのPSKを使用すること
ができます[MAY]。サーバは一つのコネクションに対し、複数のチケットを即
座に、あるいは特定のイベント後に送信することができます[MAY]。例えば、
サーバは追加のクライアント認証状態をカプセル化するために、ハンドシェイ
ク後の認証に新規のチケットを送信する場合があります。クライアントはより
新しいチケットを最初に利用し、各チケットは1度しか使わないようにすべき
です[SHOULD]。

どのチケットも、オリジナルのコネクションで利用していたものと、同じKDF
ハッシュアルゴリズムの暗号スイートでレジュームされなければならず、クラ
イアントがSNIを提供していた場合もまた、[RFC6066]のSection 3にあるよう
に、オリジナルのコネクションと同じSNI値を提供しなければなりません[MUST]。

注意:マスターシークレットのレジュームは、クライアントの2回目のネゴシエ
ーションに依存されていますが、クライアント認証を要求しないサーバは、複
写ハッシュの残りの計算とNewSessionTicketの送信を、クライアントのFinished
を待たずにサーバのFinished後に即時に行います。これはクライアントが並列
で複数のTLSコネクションを行うケースで最適化を行い、レジュームハンドシェ
イクのオーバーヘッドを減らす恩恵を受けるためです。

    struct {
        uint32 ticket_lifetime;
        uint32 ticket_age_add;
        opaque ticket_nonce<1..255>;
        opaque ticket<1..2^16-1>;
        Extension extensions<0..2^16-2>;
    } NewSessionTicket;

 ticket_lifetime
  チケットが発行されてからのチケットの寿命を、ネットワークバイトオーダ
  の32bit符号なし整数値で通知します。ticket_lifetimeに関わらず、クライ
  アントはチケットを7日以上キャッシュしてはならず[MUST NOT]、ローカル
  ポリシーによって寿命よりも早く削除される可能性があります。サーバは、
  ticket_lifetimeの寿命よりも短い期間で、チケットを有効として扱う可能
  性があります。

 ticket_age_add
  クライアントの"pre_shared_key"拡張に含まれる、チケットの寿命に曖昧さ
  を与えるために使用する、セキュアに生成された32bitのランダム値です。
  クライアント側のチケットの寿命は、クライアントから送信されたこの値に
  2^32のモジュロ演算した値を加算したものになります。サーバは送信するチ
  ケットごとに新規に値を生成しなければなりません[MUST]。

 ticket_nonce
  チケット毎にユニークな値です。

 ticket
  PSKの識別に利用されるチケットの値です。この値自身はopaqueのラベルで
  す。この値はデータベースの検索キー、または認証値を自己で暗号したもの
  である場合があります。[RFC5077]のSection 4に推奨されるチケットの構築
  メカニズムが記載されています。

 extensions
  チケットの拡張機能の値のセットです。"Extension"フォーマットはSection 4.2
  に定義されています。クライアントは認識できない拡張は無視しなければな
  りません[MUST]。

現状は、NewSessionTicket向けに定義される、"early_data"拡張のみがあり、
チケットは0-RTTデータ(Section 4.2.9)の送信を行うことを通知します。これ
は次に記述する値を含んでいます。

 max_early_data_size
  チケットを利用した時にクライアントが送信できる0-RTTデータの最大バイ
  ト量です。Application Dataのペイロードのみ(つまり、パディングではな
  いペイロードやコンテントタイプのバイトの中身)がカウント対象です。サ
  ーバはmax_early_data_sizeを超える0-RTTデータを受信した場合、
  "unexpecte_message"アラートによりコネクションを終了するべきです[SHOULD]。
  暗号マテリアルの不足によりearly dataを拒否したサーバは、コンテントか
  らパディングを分けることができないため、クライアントはearly dataレコ
  ードに大量のパディングを入れて送信することに依存するべきではありませ
  ん[SHOULD NOT]。

チケットに関連するPSKは次のように計算されます。

    HKDF-Expand-Label(resumption_master_secret,
                     "resumption", ticket_nonce, Hash.length)

ticket_nonce値は各NewSessionTicketメッセージで異なっているため、各チケ
ットで異なるPSKが導出されます。

原理的には、初回の非PSKハンドシェイクによって導出されたキーマテリアル
の寿命を新しいチケットの発行で無制限に継続することができます(大抵はピ
ア側の証明書に関連付けれられていることが多いです)。実装では、このキー
マテリアルのトータルの寿命に制限を設定することを推奨します。これらの制
限は、ピア側の証明書の寿命、証明書の失効の可能性、ピアのオンラインの
CertificateVerify署名からの時間を考慮すべきです。


4.6.2. Post-Handshake Authentication
クライアントが"post_handshake"拡張(Section 4.2.5参照)を送信した時、サ
ーバはハンドシェイク完了後であればどのタイミングでもCertificateRequest
メッセージを送信することでクライアントに認証を要求することができます[MAY]。
クライアントは、適切なAuthenticationメッセージを応答しなければなりませ
ん[MUST](Section 4.4参照)。クライアントが認証することを選択した場合、
Certificate、CertificateVerify、Finishedメッセージを送信しなければなa
りません[MUST]。クライアントが認証を拒否した場合、証明書を含まない
Certificateと、続けてFinishedメッセージを送信しなければなりません[MUST]。
すべてのクライアントの応答メッセージでは、間に他のタイプのメッセージを
含まずに、連続でなければなりません[MUST]。

"post_handshake_auth"拡張の送信がないCertificateRequestメッセージを受
信したクライアントは、"unexpected_message"のFATALアラートを送信しなけ
ればなりません[MUST]。

注意:クライアント認証はユーザの入力が必要となるため、サーバは
CertiricateRequestの送信と応答の受信の間に、他のメッセージを受信するな
ど、遅延があることを想定しておかなければなりません[MUST]。加えて、短期
間で複数のCertificateRequestを受信したクライアントは、受信した順序とは
異なる順番で応答を返すことができます[MAY](サーバはcertificate_request_context
値よって応答を識別することができます)。


4.6.3. 鍵と初期ベクトル(IV)の更新

    enum {
        update_not_requested(0), update_requested(1), (255)
    } KeyUpdateRequest;

    struct {
        KeyUpdateRequest request_update;
    } KeyUpdate;

 request_update
  KeyUpdateの受信者が、自身のKeyUpdateで応答すべきかどうかを通知します。
  実装において他の値を受信した場合、"illegal_parameter"アラートにより
  コネクションを終了しなければなりません[MUST]。

KeyUpdateハンドシェイクメッセージは、送信者が暗号鍵を更新したことを通
知します。このメッセージはピアのどちらかがFinishedメッセージを送信した
後に送信することができます。実装において、Finishedメッセージの前にKeyUpdate
メッセージを受信した場合、"unexpected_message"アラートによりコネクショ
ンを終了しなければなりません[MUST]。KeyUpdateメッセージの送信後は、送
信者はすべての通信を、Section 7.2に記述した計算方法で生成した、次の鍵
を利用して行うことになります[SHALL]。KeyUpdateを受信してから、受信者は
受信鍵を更新しなければなりません[MUST]。

request_updateフィールドに"update_requested"が設定されている場合、受信
者は次のアプリケーションデータレコードを送信する前に、request_updateフィ
ールドに"update_not_requested"を設定したKeyUpdateを送信しなければなり
ません[MUST]。このメカニズムにより、どちら側でもコネクション全体を強制
的に更新することができますが、複数のKeyUpdateを受信した時に、応答せず
に単一の更新を行うような実装になります。実装では、request_updateに
update_requestedを設定したKeyUpdateの送信と、ピアのKeyUpdateの受信の間
に、ピアがKeyUpdate受診前から既に送信されている、メッセージを受信する
可能性があることに注意してください。しかし、送受信の鍵は独立した
traffic secretから導出されているため、受信側のtraffic secretを保持して
いても、送信者が鍵を更新する前に送信されたデータのforward secrecy性は
脅かされません。

実装において、request_updateに"update_requested"を設定したKeyUpdateを
それぞれが送信し、ネゴシエーションで交錯した場合、各側のそれぞれで応答
を送信するため、結果、各側で2世代分進みます。

送信者と受信者の両方は、古い方の鍵でKeyUpdateを暗号化しなければなりま
せん[MUST]。加えて、両者共に、新しい鍵によるメッセージを受け付ける前に
古い鍵によるKeyUpdateを受信することが強制されます[MUST]。これを行わな
ければメッセージが切り捨てられる攻撃が発生する可能性があります。



5. レコードプロトコル
TLSレコードプロトコルは送信されるデータを、管理するブロックに断片化し、
レコードの保護を行い、結果を送信します。受信したデータは、検証され、復
号し、再構成され、クライアントの上位レイヤーに渡されます。

TLSレコードは、多数の上位レイヤーのプロトコルを同じレコードレイヤーを
通して多重化されます。このドキュメントではhandshake、application data、
alertの3つのタイプのコンテントについて述べています。実装では拡張機能の
折衝を行っていない限り、このドキュメントで定議されたレコードタイプ以外
を送信してはなりません[MUST NOT]。TLSの実装が予期しないレコードタイプ
を受信した場合、"unexpected_message"アラートによりコネクションを終了し
なければなりません[MUST]。新しいレコードタイプ値は、Section 11として記
載サれているように、IANAのTLS Content Type Registryで登録されています。


5.1. レコードレイヤー
レコードレイヤーは、TLSPlaintextのレコードを運搬する、2^14バイト以下の
データブロックに情報を断片化します。メッセージ境界は、ContentTypeごと
に異なります。将来的に追加されるコンテントタイプは、適切に規則を明記し
なければなりません[MUST]。これらの規則は、TLS 1.2よりも厳密となってい
ます。

ハンドシェイクメッセージは、単一のTLSPlaintextレコード、またはいくつか
のレコードに渡って断片化されたレコードがまとめられたものである可能性が
あります[MAY]。

 - ハンドシェイクメッセージは他のレコードタイプを間に入れてはなりませ
   ん[MUST NOT]。つまり、ハンドシェイクメッセージが2つ以上のレコードに
   分断された場合、間に他のレコードがあってはなりません[MUST NOT]。

 - ハンドシェイクメッセージは鍵の変更中にあってはなりません[MUST NOT]。
   実装では、レコードの境界となる鍵変更に合わせて、その前までにすべて
   のメッセージの検証を行わなければなりません[MUST]。これができない場
   合、"unexpected_message"アラートによりコネクションを終了しなければ
   なりません[MUST]。これは、ClientHello、EndOfEarlyData、ServerHello、
   Finished、KeyUpdateメッセージは鍵の変更の直前にあり、実装ではこれら
   のメッセージをレコード境界となるように調整して送信しなければならな
   いためです[MUST]。

実装では、断片化したものにパディングを含んでいたとしても、長さ0のハン
ドシェイクタイプのフラグメントを送信してはなりません[MUST NOT]。

アラートメッセージ(Section 6)は複数のレコードにまたがってフラグメント
してはならず[MUST NOT]、複数のアラートメッセージを一つのTLSPlaintextレ
コードにまとめてはなりません[MUST NOT]。言い換えると、一つのアラートタ
イプのレコードは、丁度1つのメッセージを含んでいなければなりません[MUST]。

アプリケーションデータメッセージはTLSのopaque形式のデータを格納してい
ます。アプリケーションデータメッセージは必ず暗号化され、保護されていま
す。長さ0のアプリケーションデータは、トラッフィク解析への対抗手段とし
て送信される可能性があります[MAY]。

    enum {
        invalid(0),
        alert(21),
        handshake(22),
        application_data(23),
        (255)
    } ContentType;

    struct {
        ContentType type;
        ProtocolVersion legacy_record_version;
        uint16 length;
        opaque fragment[TLSPlaintext.length];
    } TLSPlaintext;

 type
  fragmentの処理に利用する上位層のプロトコル。

 legacy_record_version
  この値は、TLS 1.3の実装ではすべてのレコードで0x0301が設定されなけれ
  ばなりません[MUST]。このフィールドは廃止されており、すべての場合にお
  いて無視しなければなりません[MUST]。前のTLSバージョンでは、いくつか
  の状況において他の値が使われることがあります。

 length
  TLSPlaintext.fragmentのバイト単位の長さ。長さは2^14バイトを超過して
  はなりません[MUST NOT]。エンドポイントが制限を超える長さのレコードを
  受信した場合、"record_overflow"アラートによりコネクションを終了しな
  ければなりません[MUST]。

 fragment
  送信されるデータです。この値は透過的であり、タイプフィールドによって
  上位層のプロトコルにより独立したブロックとして扱われます。

このドキュメントでは、バージョンとして0x0304を使うTLS 1.3について説明
しています。このバージョン値は歴史的なものであり、TLS 1.0の0x0301およ
びSSL 3.0の0x0300から導出されたものです。後方互換性を最大化するために、
レコードレイヤーのバージョンはTLS 1.0として書かれます。エンドポイント
は、Appendix Dに書かれている手順や条件で、複数のバージョンのネゴシエー
ションをサポートしています。

レコードの保護がまだ締結されていない時は、TLSPlaintextの構造は平文で直
接伝達されます。一度レコードの保護が開始されると、TLSPlaintextレコード
は暗号化され、以降のセクションに記載されているように送信されます。


続く

