The Transport Layer Security (TLS) Protocol Version 1.3
draft-ietf-tls-tls13-21

私的翻訳版です。
内容については意訳、超訳、誤りが多くあると思われますので、正確性について
保証できません。
意味が日本語で表現しにくい場合などは、カタカナでごまかしている箇所が多々
あります。

========================================================================
Abstract

   This document specifies version 1.3 of the Transport Layer Security
   (TLS) protocol.  TLS allows client/server applications to communicate
   over the Internet in a way that is designed to prevent eavesdropping,
   tampering, and message forgery.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 4, 2018.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.
========================================================================

1.  Introduction

TLSの主な目的は、通信対象間とにセキュアなチャネルを提供することです。
特に、以下の特性を提供します。


 - 認証
   サーバが常に認証されているものであること。また、クライアント側は任意
   で認証を行うことができます。認証は非対称性の暗号方式(RSA,ECDSA,EdDSA)、
   またはに事前共有鍵方式(PSK)によって行われます。

 - 機密性
   チャネル間でやり取りするデータは、エンドポイントにのみ読み取ることが
   できます。TLSはデータ長を隠しませんが、TLSレコードにパディングを付与
   することができ、解析者からデータ長を隠蔽することができます。

 - 完全性
   チャネル間を流れるデータは、攻撃者によって改竄されません。


これらの特性は、攻撃者によって完全に掌握しているネットワーク下にあっても、
保持されるべきです。


TLSは2つの要素から構成されています。

 - ハンドシェイクプロトコル(Section 4)
   ハンドシェイクプロトコルは、通信者間の認証と、暗号方式のモードとパラメ
   ータの折衝、共有鍵の確立を行います。
   ハンドシェイクプロトコルは、攻撃者によって、通信者間で異なるパラメータ
   をネゴシエーションされないように、耐タンパ性を持つように設計されていま
   す。

 - レコードプロトコル(Section 5)
   レコードプロトコルは、ハンドシェイクプロトコルによって確立されたパラメ
   ータを使い、ピアとの通信を行うために利用します。
   レコードプロトコルによって、トラッフィックをレコードに分割し、それぞれ
   を通信鍵によって独立して保護します。

TLSはアプリケーションプロトコルとは独立しています。TLSの上に、上位レイヤー
のプロトコルを透過的に利用することができます。しかし、TLSの標準では、プロ
トコルに対してどのようにTLSを付与するかを指定していません。


このドキュメントはTLS version 1.3を規定します。TLS 1.3は以前のバージョンと
直接的な互換はありませんが、すべてのTLSバージョンのクライアントおよびサー
バと相互にネゴシエーションを行えるメカニズムを有しています。

このドキュメントをもって、TLS 1.2[RFC5246]を含む、以前のTLSのRFCを廃却し、
置き換えます。TLSチケット[RFC5077]もまたSection 2.2で定義するものと置き換
えられます。Section 4.2.6では[RFC4492]で規定した楕円曲線のネゴシエーション
に関する規定を更新しています。TLS 1.3が[RFC5705]のキーマテリアルの導出方法
を更新したため(Section 7.5)、これによりOCSPメッセージもまた[RFC6066]の規定
を更新し、[RFC6961]を廃却することとなります(Section 4.4.2.1)。


1.1. 用語について

ここは割愛します。


1.2. 変更履歴

 draft-21
  - 各チケットを別のPSKと関連付けるため、チケット毎のnonceを追加しました。
  - クライアントがハンドシェイク鍵を使用してアラートを送信すべき理由を明記
    しました。
  - リキーイベント時のステートマシンを更新しました。
  - 0-RTT及びリプレイについての議論を追加します。実装において、いくつかの
    耐リプレイ攻撃のメカニズムを推奨します。

 draft-20
  - ハンドシェイク後の認証を行うため、"post_handshake_auth"拡張を追加しま
    した。
  - ひとつの圧縮ブロックに収めるため、HKDF-Expand-Labelを短いラベルにしま
    した。
  - RFC7250の方法を規定します。
  - PSK時でもハンドシェイク後のクライアント認証を使えるようにします。
    (以前の"禁止"は編集のミスになります)
  - TLS 1.3では働かない、cert_typeとuser_mappingを削除しました。
  - no_application_protocolアラートを追加しました。([RFC7301]より)
  - トラフィック解析とサイドチャネル攻撃に関する議論を追加しました。

 draft-19
  - Exporters(Section 7.5)の入力で、Hash context_valueを使用します。
  - Exportersに追加のDerive-Secretを加えます。
  - HRR(HelloRetryRequest)の時に、ClientHello1のハッシュを利用します。この
    変更によりクッキーを運搬する必要がなくなります。
  - CertificateRequestを再構成し、selectorsをすべてextensionsへ入れます。
    これによりクライアントはtrusted_ca_keysに代わって"certificate_authorities"
    の拡張も定義できるようになります。
  - レコードフレームの規定を厳格にし、チェックを要求するようにします。
  - "ticket_early_data_info"と"early_data"を統合し、ひとつの拡張にまとめま
    す。
  - end_of_early_dataをハンドシェイクメッセージに変更します。
  - キースケジュール(Section 7.1)に事前に展開するDerive-Scretを追加します。
  - "pre_shared_key"の実装の擬似要求を削除しました。
  - サーバからの"early_data"のロケーションを明記します。
  - ピアの公開鍵の検証を必須にします。
  - ステートマシン図を追加しました。

 draft-18
  - セッション再開時の、不要なresumption_pskを削除しました。 
  - Extensionの表中のsignature_algorithmsを修正しました。
  - ハンドシェイクのレジューム時、SNIが同じでないと、レジュームできないこと
    を[RFC6066]より、再度定義しました。

 draft-17
  - 0-RTT Finishとresumption_contextを削除し、PSK自身のpsk_binderフィールド
    に置き換えました。
  - PSK鍵交換のネゴシエーションを再構成しました。
  - TicketEarlyDataInfoにmax_early_data_sizeフィールドを追加しました。
  - 0-RTT のexporterを追加し、通常ハンドシェイクのexporterを変更しました。
  - TicketExtensionsをExtensionsにマージし、ticket_early_data_infoのコードポ
    イントを変更しました。
  - Client.key_sharesをHRRに置き換えました。
  - 転送鍵の導出から、余計なラベルを削除しました。

 draft-16
 - バージョンのネゴシエーションを修正しました。
 - RSASSA-PSSとEdDsaのSignatureSchemeのコードポイントを後方互換性を考慮したも
   のに変更しました。
 - HelloRetryRequest.selected_groupを拡張へ移動しました。
 - exporter contextがない場合の振る舞いを、空のcontextと同じであることを明記
   しました。
 - KeyUpdataのフォーマットを新しくし、キースケジュールとは独立して更新できる
   ように変更を行いました。
 - certificate_requiredアラートを新規に設定しました。
 - 0-RTTとPSK時のCertificateRequestを禁止しました。
 - 0-RTT時のSNIのチェックを緩和しました。

 draft-15
 - ベルリンで議論された、新しいネゴシエーション記法で記述しました。
 - ハンドシェイク中はCertificateRequest.contextは空であることを要求するように
   します。
 - 空のチケットを禁止します。
 - ネゴシエーション間で同じ暗号セットでのアプリケーションデータのメッセージを
   禁止します。
 - アラートのガイダンスを整理しました。
 - TLS 1.2の必要性を整理しました。
 - 0-RTTのタイムウィンドウのガイダンスを記載しました。
 - 古いPRNG(擬似乱数生成)に関する記述を削除しました。
 - 鍵の変更にまたがったハンドシェイクレコードのチェックを明示的に要求するよう
   にしました。
 
 draft-14
書きかけ

 draft-13

 draft-12

 draft-11

 draft-10

 draft-9

 draft-8

 draft-7

 draft-6

 draft-5

 draft-4

 draft-3

 draft-2


1.3. TLS 1.2からの主な変更点
下記にTLS 1.2とTLS 1.3の主な機能の違いを記述します。しかし、これは差異を網羅
しておらず、多くの細かい変更が存在します。

 - 対称暗号のアルゴリズムは、すでにレガシーであると考えられるため、未サポート
   としています。そのため、AEAD(認証付き暗号)のアルゴリズムのみが利用可能です。
   暗号スイートは、認証・鍵交換のメカニズムと、レコードの保護とを分離し、ハッ
   シュは鍵導出とHMACに利用するように構想が変化しています。

 - Zero-RTTモードが追加され、セキュアにアプリケーションデータをやり取りするま
   でのラウンドトリップを短縮します。

 - 静的なRSAおよびDiffie-Hellmanの暗号スイートを削除します。すべての公開鍵は鍵
   交換メカニズムで即時生成し、Forward secrecyを提供します。

 - ServerHelloより後の、すべてのハンドシェイクメッセージを暗号化します。新しく
   EncryptedExtensionを導入します。EncryptedExtensionはServerHelloの様々な
   extensionsより先に送信することができ、機密性の高い保護が可能です。

 - 鍵の導出関数について再設計されました。新しい設計では、鍵の特性を分離し、改
   善したことで、暗号技術者による解析が容易になりました。
   HMAC-based Extract-and-Expand Key Derivation Function(HKDF)は原子性を基底と
   して使用されています。

 - ハンドシェイクのステートマシンを大幅に再構成し、ChangeCipherSpecなどの無駄な
   メッセージを削除しています。

 - ed25519やed448などのECCは、基本構成として新しいsignature algorithmsに組み入
   れられています。TLS 1.3では、座標のフォーマットのネゴシエーションはなくなり
   単一のフォーマットになります。

 - その他の暗号周りの改善を行っています。これには、圧縮やカスタムDHEグループ、
   PSSへのRSAパディングの変更、DSAの削除を含んでいます。

 - version list拡張によって、TLS 1.2でネゴシエーションする方式はあまり推奨され
   ません。これは、サーバ側が選択するバージョンの実装の互換性の問題を増加させ
   ます。

 - サーバ側が古いTLSバージョンのPSKベースの暗号スイートを利用する、しないに関
   わらず、セッションの再開では、新しいPSK方式に置き換えます。

 - 参照するRFCを適切なものに更新します。


1.4. TLS 1.2に影響する更新
このドキュメントはTLS 1.2の実装に影響するいくつかの変更を定義しています。

 - バージョンダウングレード保護機構をSection 4.1.3に記載しています。

 - RSASSA-PSSをSection 4.2.3に規定しています。

 - "supported_version"のClientHello拡張をレガシーバージョンのClientHelloより優
   先して利用できるようにします。

TLS 1.3の実装において、TLS 1.2の変更もまた必要かもしれません。各セクションで詳
細を参照してください。



2. プロトコル概要
セキュアチャネルで利用される暗号パラメータは、TLSハンドシェイクプロトコルによっ
て提供されます。このTLSのサブプロトコルは、最初の通信時、クライアントとサーバに
よって利用されます。ハンドシェイクプロトコルは、ピア間のプロトコルバージョンの
ネゴシエーション、暗号アルゴリズムの選択、任意での互いの認証、そしてキーマテリ
アルの共有を行います。一度ハンドシェイクが完了すると、ピア同士は確立した鍵を利
用してアプリケーションレイヤーのトラフィックを保護します。

ハンドシェイクや他のプロトコルエラーが発生した場合、任意でエラーアラートを送信
して、接続を終了します。(Section 6)

TLSは3つの基本的な鍵交換方式をサポートします。

 - (EC)DHE (有限体または楕円曲線のDiffie-Hellman)
 - PSK-only
 - PSK with (EC)DHE

図1にTLSフルハンドシェイクを示します。


       Client                                               Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*         -------->
                                                       ServerHello  ^ Key
                                                      + key_share*  | Exch
                                                 + pre_shared_key*  v
                                             {EncryptedExtensions}  ^  Server
                                             {CertificateRequest*}  v  Params
                                                    {Certificate*}  ^
                                              {CertificateVerify*}  | Auth
                                                        {Finished}  v
                                 <--------     [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}                -------->
       [Application Data]        <------->      [Application Data]

              +  前に書かれたメッセージの拡張として送信することを表し
                 ます。

              *  任意、または状況に応じてメッセージ/拡張を送信すること
                 を表します。必ず送信するものではありません。

              {} [sender]_handshake_traffic_secretによって暗号化された
                 メッセージを表します。

              [] [sender]_application_traffic_secret_Nによって暗号化さ
                 メッセージを表します。

               図 1: TLSフルハンドシェイクメッセージ


ハンドシェイクは上記図の3つのフェーズからなります。

 - 鍵交換
   キーマテリアルの共有と暗号パラメータを決定します。このフェーズ以降、
   すべてのメッセージは暗号化されます。

 - サーバパラメータ
   クライアント認証やアプリケーションレイヤープロトコルなど、他のハン
   ドシェイクパラメータを決定します。

 - 認証
   サーバの認証、および任意でクライアントの認証と、鍵とハンドシェイク
   の整合性の確認を行います。

鍵交換のフェーズでは、クライアントはランダムのnonce(ClientHello.random)
を含めたClientHelloメッセージ(Section 4.1.2)を送信します。これは、プロ
トコルバージョン、暗号/HKDFハッシュのリスト、Diffie-Hellman鍵共有
(Section 4.2.7の"key_share"拡張を参照)、事前共有鍵のラベル(Section 4.2.10
の"pre_shared_key"の設定、追加の拡張情報などを通知します。

サーバは、ClientHelloにより適切な暗号パラメータを決定します。その際に
ネゴシエーションする接続パラメータをServerHello(Section 4.1.3)にて応答し
ます。ClientHelloとServerHelloにより共有鍵を決定します。(EC)DHE鍵が利用さ
れる場合、サーバはServerHelloの"key_share"拡張に、クライアントが通知した
グループと同じグループの一時Diffie-Hellman鍵を含めなければなりません[MUST]。
PSKが利用される場合、サーバはServerHelloの"pre_shared_key"拡張でクライア
ントが要求したPSKが選択されたかを通知します。実装は両方の拡張が通知された
場合、(EC)DHEとPSKを同時に使うことができることに留意してください。

サーバは自身のパラメータの確立のため、2つのメッセージを送信します。

 EncryptedExtensions
  証明書以外に暗号パラメータを決定する必要がないClientHello拡張に応答 しま
  す。
  [Section 4.3.1]

 CertificateRequest
  証明書を利用したクライアント認証が必要な場合、CertificateRequestによって
  要求するパラメータを通知します。このメッセージはクライアント認証が不要な
  場合は必要ありません。
  [Section 4.3.2]

最後にクライアントとサーバは認証メッセージを交換します。TLSは認証が必要な
時は毎回、同じメッセージのセットを利用します。

 Certificate
  エンドポイントの証明書と、すべての証明書の拡張に利用されます。このメッセ
  ージは、証明書による認証が不要な場合はサーバによって、CertificateRequest
  メッセージがない場合はクライアントによって不要とされ、利用されません。
  もし生の公開鍵[RFC7250]やキャッシュ情報の拡張[RFC7924]が利用された場合、
  このメッセージは証明書ではなく、サーバの長期の鍵と一致する値とが含まれる
  ことに留意してください。
  [Section 4.4.2]

 CertificateVerify
  ハンドシェイク全体のシグネチャを証明書の秘密鍵で暗号化したメッセージです。
  このメッセージは、エンドポイントが証明書による認証を不要とした場合は、必
  要ありません
  [Section 4.4.3]

 Finished
  ハンドシェイク全体のMAC(Message Authentication Code)です。このメッセージ
  はエンドポイントの鍵交換によって生成された鍵の確認に利用します。PSKの場
  合はさらにハンドシェイクの認証にも利用します。
  [Section 4.4.4]

上記のサーバのメッセージを受信した場合、クライアントはCertificate、
CertificateVerify、Finishに応じた、クライアント側の認証メッセージを送信し
ます。

これらのメッセージのポイントは、クライアントとサーバは認証された暗号を通し
て、アプリケーションデータを保護するレコードレイヤーのキーマテリアルを導出
し、ハンドシェイクを完了させなければならないことです。アプリケーションデー
タはFinishメッセージよりも前に暗号化されたレコードレイヤーを送信してないけ
ません[MUST NOT]。サーバは、クライアントの認証メッセージを受ける前にレコー
ドレイヤーを送信しますが、その時は認証されてないピアに送信することに注意し
てください。


2.1. DHE鍵共有の不一致について
もし、クライアントが適当な"key_share"拡張を提供しない場合(つまり、サーバが
受け付けないDHEまたはECDHEのグループしか送信しない場合)、サーバは図2で示す
ように、HelloRetryRequestにより不一致を通知し、クライアントは適切な
"key_share"拡張により再度ハンドシェイクを行う必要があります。もし共通する暗
号パラメータがない場合、サーバは適切なアラートによりハンドシェイクを破棄
しなければなりません[MUST]。


            Client                                               Server

            ClientHello
            + key_share             -------->
                                    <--------         HelloRetryRequest
                                                            + key_share

            ClientHello
            + key_share             -------->
                                                            ServerHello
                                                            + key_share
                                                  {EncryptedExtensions}
                                                  {CertificateRequest*}
                                                         {Certificate*}
                                                   {CertificateVerify*}
                                                             {Finished}
                                    <--------       [Application Data*]
            {Certificate*}
            {CertificateVerify*}
            {Finished}              -------->
            [Application Data]      <------->        [Application Data]

                    図2: フルハンドシェイク時のパラメータの不一致

注意:初回のClientHello/HelloRetryRequestを含む、ハンドシェイクの複写は新規の
ClientHelloをリセットしません。

以降のセクションに記載しますが、TLSは基本のハンドシェイクに、いくつかの
最適化のための変形を行うことができます。


2.2. セッションの再開と、事前鍵共有(PSK)
TLSのPSKは、通信の外でも確立することができますが、以前の通信や、セッショ
ンの再利用("session resumption")でも確立することができます。一度ハンドシ
ェイクが完了すると、サーバはクライアントに、初回ハンドシェイクによって導
出したユニークキーであるPSK IDを送信することができます。
クライアントは以降のハンドシェイクにPSK IDを利用することができます。もし
サーバがPSK IDを受け付けた場合、新しいコネクションのセキュリティコンテキ
ストは、オリジナルのコネクションに紐付いた暗号と、初回のハンドシェイクと
同じキー導出により、フルハンドシェイクに代わり自力で暗号状態を確立します。
TLS 1.2やその前では、この機能は"session IDs"や"session tickets"[RFC5077]
によって提供されていました。この2つのメカニズムはTLS 1.3では廃止されてい
ます。

PSKは、(EC)DHE鍵交換を利用したforward secrecyで共有されるものや、または
forward secrecy性は喪失するが、単体で発行できるアプリケーションデータによ
って共有されるものがあります。

図3は、PSKを通知する初回のネゴシエーションと、PSKを利用した2回目のネゴシ
エーションを示します。


          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               -------->
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                -------->
                                    <--------      [NewSessionTicket]
          [Application Data]        <------->      [Application Data]


   Subsequent Handshake:
          ClientHello
          + key_share*
          + psk_key_exchange_modes
          + pre_shared_key          -------->
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Finished}                -------->
          [Application Data]        <------->      [Application Data]

                    図3: セッションレジュームとPSKのメッセージ

サーバは、PSKによる認証が行われる場合、CertificateまたはCertificateVerify
メッセージを送信しません。クライアントがPSKによるセッションのレジュームを
要求するときは、必要であればクライアントはサーバがレジュームかフルハンド
シェイクかを選択できるように"key_share"拡張を提供すべきです。サーバは、
"pre_shared_key"拡張をつけて、PSKのネゴシエーションの応答することも、
"key_share"拡張によりforward secrecyによる(EC)DHEでネゴシエーションするこ
ともできます。

PSKが通信の外で提供されている場合、PSK IDとKDFハッシュアルゴリズムもまた
通信の外で提供されたものをPSKで利用しなければなりません[MUST]。
注意: 通信外で提供された事前共有鍵を使う時は、[RFC4086]で述べられているよ
うに、エントロピー的に十分な鍵を生成するようによく考慮するべきです。共有
したパスワードや、他の低い情報量のソースから共有シークレットを導出するこ
とはセキュアではありません。パスワードや低い情報量によるシークレットでは
PSKに基づいた、辞書攻撃の対象となりえます。PSK認証は、Diffie-Hellman鍵交
換を行っていたとしても、パスワード認証による鍵の認証が決して強固なもので
はありません。


2.3. Zero-RTTデータ
クライアントとサーバが(外部または前のハンドシェイクによって得られた)PSK
を共有している時、TLS 1.3はクライアントの初回送信("early data")でデータ
を送ることができます。クライアントは、サーバの認証と、early dataの暗号化
のためにPSKを利用します。

クライアントが外部から得たPSKをearly dataの送信に利用する時は、以下の追
加情報を提供しなければなりません[MUST]。

 - PSKで利用するTLSのバージョン。
 - PSKで利用する暗号スイート。
 - 利用する場合は、Application-Layer Protocol Negotiation(ALPN)[RFC7301]。
 - 利用する場合は、Server Name Indication(SNI)。

図4に示すように、0-RTTデータは初回送信時に1-RTT時のハンドシェイクデータを
追加したものです。その後のハンドシェイクはPSKレジュームによる1-RTTハンド
シェイクと同様です。


            Client                                               Server

            ClientHello
            + early_data
            + key_share*
            + psk_key_exchange_modes
            + pre_shared_key
            (Application Data*)     -------->
                                                            ServerHello
                                                       + pre_shared_key
                                                           + key_share*
                                                  {EncryptedExtensions}
                                                          + early_data*
                                                             {Finished}
                                    <--------       [Application Data*]
            (EndOfEarlyData)
            {Finished}              -------->

            [Application Data]      <------->        [Application Data]

                  +  前に書かれたメッセージの拡張として送信することを表し
                     ます。

                  *  任意、または状況に応じてメッセージ/拡張を送信すること
                     を表します。必ず送信するものではありません。

                  () client_early_traffic_secretによって導出された鍵によっ
                     て暗号化されたメッセージを表します。

                  {} [sender]_handshake_traffic_secretによって暗号化された
                     メッセージを表します。

                  [] [sender]_application_traffic_secret_Nによって暗号化さ
                     メッセージを表します。

                       図4: 0ラウンドトリップハンドシェイク

重要な注意:0-RTTデータは他のTLSのデータよりもセキュリティ特性が弱いです。
           具体的には、下記のことに注意してください。

 1. このデータはPSKによって導出された鍵で暗号化しているだけのため、forward
    secret特性を持っていません。
 2. コネクション間で再利用されないことは保証されていません。本来のTLS 1.3
    の1-RTTデータはサーバランダム値によって、リプレイ攻撃への耐性を持って
    いますが、0-RTTデータはServerHelloに依存しないためです。これは、クライ
    アント認証や、アプリケーションプロトコルのデータに特に関連します。同じ
    ことがearly_exporter_master_secretにも言えます。

0-RTTデータはコネクション内で複製できません(つまりサーバは同じコネクション
上での同一データを2度は受け付けません)。また攻撃者は1-RTTデータに0-RTTのデ
ータを利用することはできません(別の鍵によって暗号化するため)。Appendix E.5
に攻撃の可能性についての記述と、Section 8にリプライ攻撃に対抗するための上限
を設けることについて記述しています。



3. 記法について
このドキュメントのデータ記法は、非常に基本的かつお馴染みの文法が利用されて
います。


3.1. ベースのブロックサイズ
すべてのデータは明確に指定されて表現されています。ベースとなるブロックサイ
ズは1バイト(つまり8bit)です。複数バイトのものは、左から右、上から下へのバイ
トの連結として表現されます。マルチバイトのバイトストリームは次のように記述
されます。

    value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
            ... | byte[n-1];

このマルチバイト値のバイトオーダはネットワークバイトオーダまたはビッグエン
ディアンです。


3.2. その他
コメントは"/*"と"*/"に囲まれています。

任意の構成要素は、"[[ ]]"内に書かれます。

バイトの集合のような、他に解釈できないようなデータはopaqueとして表現します。


3.3. ベクトル
ベクトル(一次元配列)は、同質の要素のストリームです。ベクトルのサイズは、ド
キュメントの記載時か実行時に指定されます。どちらのケースでも、ベクトルは要
素数ではなく、バイト数で長さが定義されます。
固定長のベクトルTをタイプにもった、新しく定義するベクトルのタイプをT'とする
場合、以下の表記となります。

    T T'[n];

ここでは、T'はTの倍数のサイズ分であるnバイト分のデータストリームです。

次の例では、Datumは3つの連続したバイトの定義です。Dataは3つのDatumによって
構成される、合計9バイトの構造です。

    opaque Datum[3];
    Datum Data[9];

可変長のベクトルは特定の部分を指定した、<floor..ceiling>の表記で定義されま
す。これらでエンコードされた時、実際の長さはバイトストリームのベクトルの内
容より優先されます。必要以上の長さのデータがあった場合、最大サイズまでで留
めておきます。可変長データのベクトルの実際のフィールドが0であった場合、空の
ベクトルとして扱います。

    T T'<floor..ceiling>;

次の例の1つ目のmandatoryは、長さが300〜400バイトが必須のopaqueタイプのベク
トルです。これは空となることがありません。実際の長さのフィールドは2バイトの
Uint16で、400が上限になります(Section 3.4参照)。同じように、2つ目のlongerは
上限が800バイトで、uint16のため400個の要素が上限で、空となる場合もあります。
このエンコードの2バイトの長さのフィールドはベクトルの要素よりも前に置かれま
す。ベクトルの長さは1つの要素の倍数とならなければなりません。(つまり、uint16
のベクトルで長さが17バイトとなるのは異常とみなされます)

    opaque mandatory<300..400>;
        /* 長さのフィールドは2バイトで、空になることはありません */
    uint16 longer<0..800>;
        /* 0から400の16bitの符号なし整数です */


3.4. 数値型
基本の数値型のデータは符号なしバイト(uint8)です。より大きな数値型のデータは
Section 3.1で記述したように、バイト(uint8)が固定長連結することで形成されま
す。次のナンバータイプは事前定義されています。

    uint8 uint16[2];
    uint8 uint24[3];
    uint8 uint32[4];
    uint8 uint64[8];

すべての値は、ここか他の場所で定義されます。また、ネットワークバイトオーダ
(big-endian)で格納されます。;uint32の値を16進で表される、01 02 03 04の値は
10進の16909060の値になります。


3.5. 列挙型
値に弱い関連付けがされているデータのタイプをenumと呼びます。各定義は別のタ
イプです。同じタイプの列挙型のみを関連、比較する対象とすることができます。
すべての列挙型の要素は、以下の例のように値と関連付けられています。列挙型の
要素の順序に意味はないため、どのような順番でもユニークな値を関連付けること
ができます。

    enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;

プロトコルの拡張や追加のため、新しい値が定義されていきます。実装ではパース
した際に、フィールドの状態が違っていない限り、未知の値を無視する必要があり
ます。

列挙型では、最大値の定義に合わせたサイズのバイトストリームを専有します。次
の定義では、Colorタイプとして1バイトのフィールドを定義しています。

    enum { red(3), blue(5), white(7) } Color;

これは、余分な要素もなく、強制的にタグと関連付けられていないものの例です。

次のTasteの例では、2バイトのデータですが、値は現状は1,2,4しか定義されてい
ません。

    enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

列挙型の要素の名前は、スコープ内に定義されたタイプになります。最初の例の
2番めの要素を完全修飾形式で書く場合 Color.blue のようになります。対象が
特定できる場合は、このような書き方は不要になります。

    Color color = Color.blue;    /* 過剰な記述方式ですが、問題ありません */
    Color color = blue;          /* 正しい記述方式です。タイプは暗黙的です */

名前への関連付けは、ユニークである必要はありません。列挙の値は2つのピリオ
ドを間に入れた書き方で、範囲で同じ名前を適用することができます。これは、
スペースを予約しておく上で、非常に便利な方法です。

    enum { sad(0), meh(1..254), happy(255) } Mood;


3.6. 構造体
構成を簡易に書くため、基本型から構成される構造体を利用できます。各宣言は、
ユニークなものになります。記法は、C言語のように定義します。

    struct {
        T1 f1;
        T2 f2;
        ...
        Tn fn;
    } [[T]];

構造体のフィールドは、列挙型と同じように、タイプ名を利用した修飾子になり
ます。例えば、T.f2は上で書かれた宣言の2番目の要素への参照となります。構
造体は他の構造体に埋め込まれて定義されることがあります。どの構造体も他で
定義されているものになります。


3.7. 定数
固定値に関連付けられるものは、"="を使って、以下のように記述されます。

    struct {
        T1 f1 = 8;   /* T.f1 は必ず8である必要があります */
        T2 f2;
    } T;


3.8. 可変構造
実際の動作時に得られる値を元にして、解釈する構造を変更させる定義を行う
ことができます。selectorは、構造体の定義で取りうる範囲の変数でなければ
なりません。可変構造の決定因子はラベルの参照によって記述されます。この
ような実行時の変数によって選択される構造は、表現時の記法の段階では決定
されていません。

    struct {
        T1 f1;
        T2 f2;
        ....
        Tn fn;
        select (E) {
            case e1: Te1;
            case e2: Te2;
            ....
            case en: Ten;
        } [[fv]];
    } [[Tv]];

例:

    enum { apple(0), orange(1) } VariantTag;

    struct {
        uint16 number;
        opaque string<0..10>; /* variable length */
    } V1;

    struct {
        uint32 number;
        opaque string[10];    /* fixed length */
    } V2;

    struct {
        VariantTag type;
        select (VariantRecord.type) {
            case apple:  V1;
            case orange: V2;
        };
    } VariantRecord;


4. ハンドシェイクプロトコル
ハンドシェイクプロトコルは、コネクションのセキュリティパラメータをネ
ゴシエーションするために使われます。ハンドシェイクメッセージは、コネ
クションの状態により、1つ以上のカプセル化されたTLSPlaintextまたは、
TLSCiphertextのTLSレコードレイヤーによって行われます。

    enum {
        client_hello(1),
        server_hello(2),
        new_session_ticket(4),
        end_of_early_data(5),
        hello_retry_request(6),
        encrypted_extensions(8),
        certificate(11),
        certificate_request(13),
        certificate_verify(15),
        finished(20),
        key_update(24),
        message_hash(254),
        (255)
    } HandshakeType;

    struct {
        HandshakeType msg_type;    /* handshake type */
        uint24 length;             /* bytes in message */
        select (Handshake.msg_type) {
            case client_hello:          ClientHello;
            case server_hello:          ServerHello;
            case end_of_early_data:     EndOfEarlyData;
            case hello_retry_request:   HelloRetryRequest;
            case encrypted_extensions:  EncryptedExtensions;
            case certificate_request:   CertificateRequest;
            case certificate:           Certificate;
            case certificate_verify:    CertificateVerify;
            case finished:              Finished;
            case new_session_ticket:    NewSessionTicket;
            case key_update:            KeyUpdate;
        } body;
    } Handshake;

プロトコルメッセージは、Section 4.4.1で定義された、およびSection 2
で示している順序で送信しなければあなりません[MUST]。通信相手から予
期しない順序でハンドシェイクメッセージを受信した場合、
"unexpected_message"のアラートを送信し、ハンドシェイクを破棄しなけ
ればなりません[MUST]。


4.1. 鍵交換メッセージ
鍵交換メッセージは、後のハンドシェイクやデータを保護するためのトラ
フィックキーを含めた、セキュリティパラメータを共有するため、クライ
アントととサーバのセキュリティ能力の決定に利用されます。


4.1.1. 暗号のネゴシエーション
TLSでは、暗号のネゴシエーションは、ClientHelloの次の4つのオプショ
ンの要求で、クライアントから開始されます。

 - クライアントがサポートしている、AEADアルゴリズム/HKDFハッシュペ
   アの暗号スイートのリスト。

 - クライアントがサポートしている(EC)DHEグループを"supported_groups"
   拡張(Section 4.2.6)と、このグループのための(EC)DHE共有の"key_share"
   拡張(Section 4.2.7)。

 - クライアントが受け入れ可能なシグネチャアルゴリズムを通知する、
   "signature_algorithms"拡張(Section 4.2.3)。

 - クライアントが知っている対称鍵のリストを含んだ"pre_shared_key"
   拡張(Section 4.2.10)および、PSKを利用する鍵交換方式を通知する
   "psk_key_exchange_modes"拡張(Section 4.2.8)。   

サーバがPSKを選択しない場合、上の3つのオプションはそれぞれ独立して
います。サーバは、暗号スイートと、鍵を確立するための(EC)DHEグループ
と鍵共有のペアと、クライアントに自身の認証させるためのシグネチャア
ルゴリズムと証明書のペアとを独立して選択することができます。
もし、受信した"supported_groups"とサーバがサポートしているグループ
とに一致するものがなかった場合は、サーバは"handshake_failure"か、
"insufficient_security"アラートを送信してハンドシェイクを破棄しなけ
ればなりません[MUST]。

サーバがPSKを選択した場合、鍵を確立する方式も、クライアントから通知
された"psk_key_exchange_modes"拡張(現状は、PSKのみか(EC)DHEを伴いま
す)から選択する必要があります[MUST]。(EC)DHEを伴わないPSKを使う場合、
前の節での非PSKのケースとは異なり、"supported_groups"パラメータが一
致しないことは致命的にはならないことに注意してください。

サーバが(EC)DHEグループを選択し、クライアントが適合する"key_share"拡
張を初回のClientHelloに提供しない場合、サーバはHelloRetryRequestメッ
セージ(Section 4.1.4)を応答しなければなりません[MUST]。

サーバがパラメータの選択に成功し、HelloRetryRequestも不要であった場合、
選択したパラメータSeverHelloにて下記のように通知します。

 - PSKを利用する場合、サーバーは"pre_shared_key"拡張に選択した鍵を入
   れて送信します。

 - PSKを利用しない場合は必ず(EC)DHEと証明書ベースの認証を利用します。

 - (EC)DHEが利用される時は、サーバは"key_share"拡張もまた提供します。

 - 証明書による認証を行う時は、サーバはCertificateメッセージ(Section 4.4.2)
   とCertificateVerifyメッセージ(Section 4.4.3)を送信する。TLS 1.3を
   規定するこの文書では、PSKと証明書のどちらかは必ず利用されるが、両
   方を同時に利用することはない。ただし、将来的に両方を同時に利用する
   方法を定義する可能性はあります。

サーバがサポートするパラメータのセットを折衝できない場合(つまり、クラ
イアントとサーバ間で一致するパラメータがない場合)、"handshake_failure"
または"insufficient_security"のfatalアラートでハンドシェイクを破棄する
必要があります[MUST]。(Section 6を参照)


4.1.2. Client Hello
クライアントが最初にサーバと接続する時、最初のメッセージとしてClientHello
の送信が要求されます[REQUIRED]。クライアントはサーバがClientHelloに対し
てHelloRetryRequestを応答した場合もまた、ClientHelloを送信します。この
場合、クライアントは下記の場合を除いて、改変することなしに同じClientHello
を送信しなければなりません[MUST]。

 - HelloRetryRequestに"key_share"拡張が提供されている場合、通知されたグ
   ループに含まれる、1つのKeyShareEntryの共有リストに置き換えます。

 - もし"early_data"拡張(Section 4.2.9)があった場合は削除します。Early
   dataはHelloRetryRequestの後は利用できません。

 - HelloRetyrRequestに"cookie"拡張が提供されている場合は、それを取り込み
   ます。

 - "pre_shared_key"拡張がある場合、"obfuscated_ticket_age"によって再計算
   を行い、値を更新します。また、サーバの通知した暗号スイートとPSKは任意
   で削除しても構いません。

TLS 1.3は再ネゴシエーションを禁止しているため、サーバが他のタイミングで
ClientHelloを受信した場合、"unexpected_message"アラートにより、コネクショ
ンを終了しなければなりません[MUST]。

サーバがTLS 1.3以前のバージョンのコネクションを確立している時に、TLS 1.3
のClientHelloの再ネゴシエーションを受けた場合、前バージョンを保持し続けな
ければなりません[MUST]。特に、TLS 1.3でネゴシエーションは行ってはいけませ
ん[MUST NOT]。


ClientHelloメッセージ構造:

    uint16 ProtocolVersion;
        opaque Random[32];
      
        uint8 CipherSuite[2];    /* Cryptographic suite selector */
      
        struct {
            ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
            Random random;
            opaque legacy_session_id<0..32>;
            CipherSuite cipher_suites<2..2^16-2>;
            opaque legacy_compression_methods<1..2^8-1>;
            Extension extensions<8..2^16-1>;
        } ClientHello;

 legacy_version
  以前のTLSバージョンでは、このフィールドはバージョンのネゴシエーションと
  クライアントがサポートしている最も新しいバージョンを通知するために利用
  されていました。経験的に多くのサーバは正しくバージョンのネゴシエーショ
  ンを実装しておらす、サーバは自身がサポートしているよりも高いバージョン
  のClientHelloを受け付けない、バージョンに不寛容であることがわかっていま
  す。TLS 1.3では、バージョンの設定を"supported_versions"拡張(Section 4.2.1)
  で通知し、legacy_versionフィールドはTLS 1.2である0x0303が設定されなけれ
  ばなりません[MUST]。

 random 
  セキュアな乱数生成機によって生成された32バイトの値。
  Appendix Cの追加情報を参照。

 legacy_session_id
  TLS 1.3以前のTLSでは、このバージョンでPre-Shared Keys(Section 2.2参照)
  に統合された、"session resumption"をサポートしていました。このフィール
  ドはTLS 1.3をネゴシエーションするサーバは無視する必要があります[MUST]。
  また、クライアントはTLS 1.3より前のサーバによるセションIDをキャッシュし
  てはならず、長さ0のベクトル(つまり、0バイトの長さのフィールド)を設定し
  なければなりません[MUST]。

 cipher_suites
  クライアントがサポートしている対称暗号のリストです。具体的には、レコー
  ド保護アルゴリズム(秘密鍵の長さを含む)と、HKDFに利用されるハッシュとが
  クライアントが優先する順番で通知します。このリストに含まれる暗号スイー
  トがサーバで認識できない、サポートしない、利用を望まない場合はサーバは
  その暗号スイートを無視して、残りの暗号スイートを見ていかなければなりま
  せん[MUST]。値はAppendix B.4で定義されています。クライアントがPSK鍵を
  確立しようとするなら、少なくとも1つのPSKに関連したハッシュの暗号スイー
  トを通知するべきです[SHOULD]。

 legacy_compression_methods
  TLS 1.3以前のバージョンでは、このフィールドにサポートしている圧縮メソッ
  ドのリストを送信していました。TLS 1.3のすべてのClientHelloでは、このベ
  クトルには以前のバージョンで"null"圧縮を表す1バイトの0の値を設定しなけ
  ればなりません[MUST]。このフィールドに他の値を含んだTLS 1.3のClientHello
  を受信した場合、サーバは"illegal_parameter"アラートによりハンドシェイク
  を破棄しなければなりません[MUST]。TLS 1.3サーバはTLS 1.2より前のバージョ
  ンの他の圧縮メソッドを含んだClientHelloを受信する可能性がありますが、そ
  の場合は以降に記述する手順で前バージョンのTLSにしなければならない[MUST]
  ことに留意してください。TLS 1.3のClientHelloは、0x0303のlegacy_versionに
  よりTLS 1.2と同一に見えますが、suppoerted_version拡張により、0x0304の最
  も高いバージョンを通知します。

 extensions
  クライアントはextensionsフィールドにより、サーバへ拡張機能を要求します。
  "Extension"のフォーマットはSection 4.2に定義されています。TLS 1.3では、
  以前のバージョンのClientHelloに存在した機能が、拡張へと移動されているた
  め、特定の拡張は必須となっています。サーバは理解できない拡張については
  無視しなければなりません[MUST]。

すべてのTLSバージョンは、compression_methodフィールドの後ろに、任意で拡張
フィールドを付けることができます。TLS 1.3のClientHelloメッセージは必ず拡張
を含める必要があります(少なくとも、"supported_versions"はTLS 1.2のClientHello
と区別するため)。しかし、TLS 1.3サーバは拡張フィールドがない、以前のバージョ
ンのClientHelloメッセージを受ける可能性があります。ClientHelloのcompression_methods
フィールドの後ろの拡張の存在の判定により検知することができます。この任意の
データの検知は、通常のTLSの可変フィールドとは異なりますが、以前のTLSの拡張
の定義と互換性があるように利用されることに留意シてください。
TLS 1.3サーバは、TLS 1.3でネゴシエーションする場合は"supported_version"拡張
の存在を最初にチェックする必要があります。TLS 1.3より前のバージョンのTLSで
ネゴシエーションする場合、サーバはlegacy_compression_methodsより後にデータ
がないか、データ無しの有効な拡張ブロックを含んでいることをチェックしなけれ
ばなりません[MUST]。もしそうではないなら、"decode_error"アラートによりハン
ドシェイクを破棄しなければなりません[MUST]。

クライアントが拡張機能を追加した要求を行った時で、その機能をサーバがサポー
ト指定なかった場合、クライアントはハンドシェイクを破棄することができます[MAY]。

ClientHelloメッセージの送信後、クライアントはServerHelloかHelloRetryRequest
メッセージを待ちます。early dataを利用する場合、クライアントは次のハンドシェ
イクメッセージを待つ間、Section 2.3のearly application dataを送信することが
できます。


4.1.3. Server Hello
サーバはClientHelloのパラメータが受付可能なものであった場合、ハンドシェイク
を継続するため、応答としてServerHelloメッセージを送信します。

ServerHelloメッセージ構造:

    struct {
        ProtocolVersion version;
        Random random;
        CipherSuite cipher_suite;
        Extension extensions<6..2^16-1>;
    } ServerHello;

 version
  このフィールドはこのコネクションで利用するTLSバージョンを格納します。サー
  バはClientHelloのsupported_varsion拡張のリストからバージョンを選択するか、
  TLS 1.2以前のバージョンでネゴシエーションを行わなければなりません[MUST]。
  クライアントは、望まないバージョンを受けた場合、ハンドシェイクを破棄しな
  ければなりません[MUST]。このTLS 1.3の値は、0x0304です。(後方互換について
  の詳細はAppendix Dを参照してください)

 random
  セキュアな乱数生成機によって生成された32バイトの値です。
  Appendix Cの追加情報を参照。
  TLS 1.2とTLS 1.1でネゴシエーションを行う場合、最後の8バイトは後述にある
  ように上書きする必要がありますが、他はランダムのままである必要がありま
  す[MUST]。この値は、ClientHello.randomとは独立して、サーバによって生成
  されなければなりません[MUST]。

 cipher_suite
  ClientHello.cipher_suitesのリストからサーバによって選択された1つの暗号
  スイートの値です。クライアントは、要求していない暗号スイートを受けた場
  合、"illegal_parameter"のアラートによりハンドシェイクを破棄しなければな
  りません[MUST]。

 extensions
  拡張機能のリストです。ServerHelloは暗号コンテキストを確立するために要求
  された拡張のみを含めなければなりません[MUST]。今のところ、"key_share"や
  "pre_shared_key"などの拡張のみです。現状、すべてのTLS 1.3 ServerHelloメ
  ッセージは前述の2つの拡張、または(EC)DHE鍵で確立するPSKを利用するかの
  いずれか一方、あるいは両方を含めます。他の拡張はEncryptedExtensionsメッ
  セージとして送信されます。

TLS 1.3はサーバランダムにダウングレード保護のメカニズムを持っています。
TLS 1.3サーバはTLS 1.2以前のバージョンとして、ClientHelloに応答する場合、
最後の8バイトを特定の値にする必要があります[MUST]。

TLS 1.3サーバがTLS 1.2でネゴシエーションを行う場合、サーバランダムの値を
次のように設定しなければなりません[MUST]。

 44 4F 57 4E 47 52 44 01

TLS 1.1以前のバージョンでネゴシエーションを行う場合、サーバランダムの値を
次のように設定しなければなりません。これは、TLS 1.3サーバは必須であり[MUST]、
TLS 1.2サーバは推奨の[SHOULD]動作です。

 44 4F 57 4E 47 52 44 00
 
TLS 1.3クライアントは、TLS 1.2以前のServerHelloを受信した場合、サーバラン
ダムの最後の8バイトが上記の値に一致していないことをチェックする必要があり
ます[MUST]。TLS 1.2クライアントもまた、TLS 1.1以前のServerHelloを受信した
場合、サーバランダムの最後の8バイトが上記の2つ目の値に一致していないことを
チェックすべきです[SHOULD]。もし値の一致があるのであれば、クライアントは
"illegal_parameter"のアラートによってハンドシェイクを破棄しなければなりま
せん[MUST]。これは、Finishedの交換で行われるダウングレード攻撃に対する保護
メカニズムです。これは、クライアントとサーバのランダム値によるシグネチャを
含んだ、TLS 1.2以前にあるServerKeyExchangeメッセージが、攻撃者によって脆弱
なものに書き換えられたことを検知できないためです。このダウングレード保護は、
静的なRSAを利用する場合は提供されません。

注意:これは[RFC5246]より変更された点であるため、実際の多くのTLS 1.2クライ
アントやサーバは上記の振る舞いを行いません。

レガシーのTLSクライアントは、TLS 1.2以前にある再ネゴシエーションを行えます
が、再ネゴシエーション中にTLS 1.3のServerHelloを受信した場合は、
"protocol_version"のアラートによってハンドシェイクを破棄しなければなりませ
ん[MUST]。TLS 1.3でネゴシエーションをしている場合は、再ネゴシエーションを
行うことはできないことに注意してください。

RFC EDITOR:この文章は削除される予定です
ドラフトバージョンの実装(Section 4.2.1.1参照)では、クライアントおよびサーバ
に、この実装を行うべきではありません。RFC化前のクライアントがRFC化後のサー
バに接続する、またはその逆では、TLS 1.2にダウングレードするようにすべきです。
このメカニズムを有効にする場合、相互的に失敗が起きるようにするべきです。


4.1.4. Hello Retry Request
サーバは、ClientHelloに受け入れ可能なパラメータはあるが、ハンドシェイクを進
める情報が十分になかった場合、応答としてHelloRetryRequestメッセージを送信し
ます。

HelloRetryRequestメッセージ構造:

    struct {
        ProtocolVersion server_version;
        CipherSuite cipher_suite;
        Extension extensions<2..2^16-1>;
    } HelloRetryRequest;

version、cipher_suite、extensionsフィールドは、ServerHelloのものと同じ意味
を持っています。サーバはクライアントのClientHelloに必要な拡張のみを送信すべ
きです。ServerHelloと同様に、HelloRetryRequestは、"cookie"拡張(Section 4.2.2参照)
を除き、最初に提供されたクライアントのClientHelloに要求されていない拡張を含
めてはいけません[MUST NOT]。

HelloRetryRequestを受信した場合、クライアントはその拡張ブロックが空ではない
ことを確認しなければなりません[MUST]。空であった場合、"decode_error"アラート
によりハンドシェイクを破棄しなければなりません[MUST]。クライアントは、
HelloRetryRequestがClientHelloから何らかの変更が行われている場合、
"illegal_parameter"アラートによりハンドシェイクを破棄しなければなりません[MUST]。
もし同じコネクション上で2回めのHelloRetryRequestを受けた場合(つまり、
HelloRetryRequestの応答のClientHelloでHelloRetryRequestを受けた場合)、
"unexpected_message"アラートによりハンドシェイクを破棄しなければなりません[MUST]。

つまり、クライアントはHelloRetryRequestのすべての拡張を受け付け、更新した
2つ目のClientHelloを送信しなければなりません[MUST]。HelloRetryRequestの拡張
の定義は次のようになっています。

 - cookie(Section 4.2.2参照)

 - key_share(Section 4.2.7参照)

加えて、ClientHelloの更新には、クライアントは選択した暗号スイートに関連しな
い事前共有鍵を要求すべきではありません[SHOULD NOT]。これは、クライアントが
2つ目のClientHelloで複数のハッシュの計算を避けるためです。要求していない暗
号スイートを受け取ったクライアントはハンドシェイクを破棄しなければなりませ
ん[MUST]。サーバは更新されたClientHelloに合った暗号スイートによるネゴシエー
ションを保証しなければなりません[MUST]。ServerHelloを受信した上で、クライア
ントは暗号スイートにHelloRetryRequestで要求したものが提供されていることをチェ
ックしなければならず[MUST]、提供されていなかった場合は"illegal_parameter"ア
ラートによりハンドシェイクを破棄します。


4.2. Extensions
多くのTLSメッセージは、タグ長によってエンコードされた拡張構造を含んでいます。


    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;

   enum {
       server_name(0),                             /* RFC 6066 */
       max_fragment_length(1),                     /* RFC 6066 */
       status_request(5),                          /* RFC 6066 */
       supported_groups(10),                       /* RFC 4492, 7919 */
       signature_algorithms(13),                   /* RFC 5246 */
       use_srtp(14),                               /* RFC 5764 */
       heartbeat(15),                              /* RFC 6520 */
       application_layer_protocol_negotiation(16), /* RFC 7301 */
       signed_certificate_timestamp(18),           /* RFC 6962 */
       client_certificate_type(19),                /* RFC 7250 */
       server_certificate_type(20),                /* RFC 7250 */
       padding(21),                                /* RFC 7685 */
       key_share(40),                              /* [[this document]] */
       pre_shared_key(41),                         /* [[this document]] */
       early_data(42),                             /* [[this document]] */
       supported_versions(43),                     /* [[this document]] */
       cookie(44),                                 /* [[this document]] */
       psk_key_exchange_modes(45),                 /* [[this document]] */
       certificate_authorities(47),                /* [[this document]] */
       oid_filters(48),                            /* [[this document]] */
       post_handshake_auth(49),                    /* [[this document]] */
       (65535)
   } ExtensionType;

 - "extension_type"は拡張の種類を特定します。
 - "extension_data"は特定の拡張の種類の情報を格納します。

拡張種類のリストは、Section 11で述べられているように、IANAによってメンテ
ナンスされています。

拡張は、通常はリクエスト/レスポンス形式の構造を取りますが、いくつかの拡張
はレスポンスを不要とする、通知のみのものもあります。クライアントはClientHello
メッセージでリクエストの拡張を送信し、サーバはこれに対する応答の拡張を
ServerHello、EncryptedExtensions、HelloRetryRequestおよびCertificateメッセ
ージに載せて送信します。サーバのリクエストの拡張は、クライアントの認知の
Certificateメッセージ応答[MAY]に対する要求をCertificateRequestメッセージに
て送信します。サーバはまた、クライアントが直接応答しなくても、NewSessionTicket
に要求されていない拡張を送信することができます[MAY]。

実装として、リモートのエンドポイントが"cookie"拡張を除き、一致する拡張リク
エストを拡張を送信してこなかった場合、それに応じる拡張を応答してはなりませ
ん[MUST]。そのような拡張を受信した場合は、エンドポイントは"unsupported_extension"
アラートにより、ハンドシェイクを破棄しなければなりません[MUST]。

次の表は、各メッセージに付与できる拡張を記載しています。
表記として: CH (ClientHello)、SH (ServerHello)、EE (EncryptedExtensions)、
CT (Certificate)、CR (CertificateRequest)、NST (NewSessionTicket)、
HRR (HelloRetryRequest)になります。実装として、解釈はできるがメッセージに
紐付かない拡張を受信した場合は、"illegal_parameter"アラートによりハンドシェ
イクを破棄しなければなりません[MUST]。

    +--------------------------------------------------+-------------+
    | Extension                                        |     TLS 1.3 |
    +--------------------------------------------------+-------------+
    | server_name [RFC6066]                            |      CH, EE |
    |                                                  |             |
    | max_fragment_length [RFC6066]                    |      CH, EE |
    |                                                  |             |
    | status_request [RFC6066]                         |  CH, CR, CT |
    |                                                  |             |
    | supported_groups [RFC7919]                       |      CH, EE |
    |                                                  |             |
    | signature_algorithms [RFC5246]                   |      CH, CR |
    |                                                  |             |
    | use_srtp [RFC5764]                               |      CH, EE |
    |                                                  |             |
    | heartbeat [RFC6520]                              |      CH, EE |
    |                                                  |             |
    | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
    |                                                  |             |
    | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
    |                                                  |             |
    | client_certificate_type [RFC7250]                |      CH, EE |
    |                                                  |             |
    | server_certificate_type [RFC7250]                |      CH, CT |
    |                                                  |             |
    | padding [RFC7685]                                |          CH |
    |                                                  |             |
    | key_share [[this document]]                      | CH, SH, HRR |
    |                                                  |             |
    | pre_shared_key [[this document]]                 |      CH, SH |
    |                                                  |             |
    | psk_key_exchange_modes [[this document]]         |          CH |
    |                                                  |             |
    | early_data [[this document]]                     | CH, EE, NST |
    |                                                  |             |
    | cookie [[this document]]                         |     CH, HRR |
    |                                                  |             |
    | supported_versions [[this document]]             |          CH |
    |                                                  |             |
    | certificate_authorities [[this document]]        |      CH, CR |
    |                                                  |             |
    | oid_filters [[this document]]                    |          CR |
    |                                                  |             |
    | post_handshake_auth [[this document]]            |          CH |
    +--------------------------------------------------+-------------+

複数の別のタイプの拡張がある時は、拡張の順序は"pre_shared_key"を除いて
どのような順番でも問題ありません[MAY]。Section 4.2.10に記載の"pre_shared_key"
はClientHelloの拡張の最後尾になければなりません[MUST]。拡張は、同じ拡張
ブロックに、複数の同一タイプの拡張を入れてはいけません[MUST NOT]。

TLS 1.3ではTLS 1.2と異なり、PSKのレジュームでも、拡張は各ハンドシェイク
でネゴシエーションが行われます。しかし、0-RTTパラメータは事前のハンドシェ
イクでネゴシエーションされ、合わない場合は0-RTTは拒否されます(Section 4.2.9参照)。

新しいプロトコルと既存のプロトコルとには、微細な(または微細ではない)相互
作用として、全体のセキュリティ性の重大な減少が発生するかもしれません。次
に新しい拡張を設計する上での取るべき考えを考察しています。

 - いくつかの場合、サーバは同意しない拡張をエラー状態としたり、ただ単に
   サポートしている特定の機能のみを選択します。一般的にエラーアラートは
   前者で返し、応答の拡張フィールドは後者で返します。

 - 拡張は可能な限り、力任せの(力任せではなくとも)攻撃を防ぐように設計さ
   れるべきです。この原則は、セキュリティ上の問題を引き起すような機能に
   関係なく守られるべきです。事実として、拡張フィールドまでをFinishメッ
   セージの入力とすることはセキュリティ的に十分ではありますが、ハンドシェ
   イクフェーズでメッセージの意味を変更する際は、特段の注意が必要です。
   設計者および実装者は、攻撃者がメッセージの改変や拡張の挿入、削除、置
   き換えが可能であり、それが認証されたハンドシェイクとなることまでを想
   定しておくべきです。


4.2.1. Supported Versions

    struct {
        ProtocolVersion versions<2..254>;
    } SupportedVersions;

"supported_versions"拡張は、クライアントが自身のサポートしているTLSバー
ジョンを通知するために使用されます。拡張には、優先度が高い順番でサポート
バージョンのリストを含んでいます。実装の詳細として、この拡張には利用でき
るすべてのTLSバージョンを入れて送信しなければなりません[MUST]。(実装とし
て、最小構成は0x0304を含める必要がありますが、もし以前のTLSバージョンの
ネゴシエーションが可能であれば、それらも追加されるべきです[MUST])

この拡張がなかった場合、たとえClientHello.legacy_versionが0x0304以降であっ
たとしても、サーバは[RFC5246]のTLS 1.2以前のバージョンでネゴシエーション
を行う必要があります[MUST]。サーバはClientHelloのlegacy_versionが0x0304
以降にあった場合、ハンドシェイクを破棄しても構いません[MAY]。

拡張が存在した場合は、サーバはClientHello.legacy_versionの値を無視すべき
で[MUST]、"supported_versions"拡張のみによってクライアントの設定を決定し
なければなりません[MUST]。サーバは拡張からのみ利用するTLSバージョンを選
択し[MUST]、不明なバージョンは無視しなければなりません[MUST]。これは一方
のサポート範囲が異なっていても、TLS 1.2以前のバージョンとのネゴシエーショ
ンを可能にするためのメカニズムという点に留意シてください。以前のバージョ
ンをサポートするTLS 1.3の実装は、TLS 1.2をサポートすべきです[SHOULD]。サ
ーバは、ClientHelloにこの拡張を含むが、その中のリストに0x0304を含まない
ものを受信した時の用意をしておくべきです。

サーバは"supported_versions"拡張を送信してはいけません[MUST NOT]。サーバ
が選択したバージョンは、以前のTLSバージョンのように、ServerHello.version
フィールドに格納されます。


4.2.1.1. ドラフトバージョンの通知

RFC EDITOR:この文章は削除される予定です

最終的にRFCとして、TLS 1.3のバージョンは0x0304になりますが、ドラフトバー
ジョンの実装は代わりにServerHello.versionとHelloRetryRequest.server_version
には{0x7f,draft_version}を通知すべきです[SHOULD]。例えば、draft-17では
{0x7f, 0x11}としてエンコードされます。これは、RFC化前の実装において、た
とえ互換性がなくとも、互いに安全にネゴシエーションを行うためのものです。


4.2.2. Cookie

    struct {
        opaque cookie<1..2^16-1>;
    } Cookie;

Cookiesは2つの主目的を果たします。

 - サーバがクライアントに対し、強制的に到達可能なネットワークアドレスを
   開示させます(つまり、DoSを防御するかを判断する材料を提供します)。こ
   れは到達不可能なコネクションに対して有用性があります([RFC6347]の例を
   参照)。

 - サーバがクライアントに状態の管理を任せることができます。つまり、どの
   ような状態でもHelloRetryRequestが送信できます。サーバはHelloRetryRequest
   のcookieに、ClientHelloのハッシュを入れることで、これができます。(適
   切なアルゴリズムによって保護されます)。

HelloRetryRequestを送信した時は、サーバは"cookie"拡張をクライアントに提
供することができます[MAY](これは、この拡張のみのもので、ClientHelloの通
常のルールの例外になります)。新規のClientHelloを送信する際、クライアント
は新規のClientHelloの"cookie"拡張に、受信したHelloRetryRequestの拡張を複
写しなければなりません[MUST]。クライアントはその後のコネクションではcookie
を使用してはいけません[MUST NOT]。


4.2.3. Signature Algorithms
クライアントはデジタル署名に使われる可能性のあるシグネチャアルゴリズムを
"signature_algorithms"拡張によってサーバに通知します。証明書によってサー
バの認証を行いたい場合は、クライアントはこの拡張を送信する必要があります[MUST]。
サーバが証明書による認証を行っている場合かつ、クライアントが
"signature_algorithms"を送信しない場合、サーバは"missing_extension"アラー
トによりハンドシェイクを破棄しなければなりません[MUST](Section 9.2参照)。

ClientHelloの、この拡張の"extension_data"フィールドはSignatureSchemeList
の値が格納されます。

    enum {
        /* RSASSA-PKCS1-v1_5 algorithms */
        rsa_pkcs1_sha256(0x0401),
        rsa_pkcs1_sha384(0x0501),
        rsa_pkcs1_sha512(0x0601),

        /* ECDSA algorithms */
        ecdsa_secp256r1_sha256(0x0403),
        ecdsa_secp384r1_sha384(0x0503),
        ecdsa_secp521r1_sha512(0x0603),

        /* RSASSA-PSS algorithms */
        rsa_pss_sha256(0x0804),
        rsa_pss_sha384(0x0805),
        rsa_pss_sha512(0x0806),

        /* EdDSA algorithms */
        ed25519(0x0807),
        ed448(0x0808),

        /* Legacy algorithms */
        rsa_pkcs1_sha1(0x0201),
        ecdsa_sha1(0x0203),

        /* Reserved Code Points */
        private_use(0xFE00..0xFFFF),
        (0xFFFF)
    } SignatureScheme;

    struct {
        SignatureScheme supported_signature_algorithms<2..2^16-2>;
    } SignatureSchemeList;

注意:このenumは、TLS 1.2にある"SignatureAlgorithm"拡張を置き換えるもの
であるため、"SignatureScheme"と名付けられています。このRFC上では、
"署名アルゴリズム"として記載します。

各SignatureSchemeの値は、クライアントが検証しようとする署名アルゴリズム
のリストです。値は優先度の順番で通知されます。署名アルゴリズムはダイジェ
ストからではなく、任意の長さのメッセージから生成される点に留意してくださ
い。従来のダイジェストによるアルゴリズムは、特定のハッシュアルゴリズムを
入力とする最初のハッシュと、処理を継続することを、TLS上に定義されるべき
です。上記のコードポイントのグループは、次のような意味を持っています。

 RSASSA-PKCS1-v1_5アルゴリズム
  [SHS]に定義されているハッシュアルゴリズムであるRSASSA-PKCS1-v1_5[RFC8017]
  を利用した署名アルゴリズムを通知します。これらの値は証明書の署名に利用
  されるだけで、TLSハンドシェイクメッセージの署名に利用することを意味し
  ていません。

 ECDSAアルゴリズム
  ANSI X9.62[X962]及びFIPS 186-4[DSS]に定義されている曲線と、[SHS]に定義
  されているハッシュアルゴリズムによるECDSA[ECDSA]を使用した署名アルゴリ
  ズムを通知します。署名はDERエンコード[X690]のECDSA-Sig-Valueの構造をし
  ています。

 RSASSA-PSSアルゴリズム
  MGF1(マスク生成関数1)によるRSASSA-PSS[RFC8017]を利用した署名アルゴリズ
  ムを通知します。マスク生成関数を使用したダイジェストと、署名されたダイ
  ジェストは[SHS]で定義されたハッシュアルゴリズムです。署名されたTLSハン
  ドシェイクメッセージを利用する場合、ソルトの長さは、ダイジェストの出力
  長と同じにしなければなりません[MUST]。このコードポイントはこのRFCで新し
  く規定されたものですが、TLS 1.2に対しても適用するように定義されています。

 EdDSAアルゴリズム
  [RFC8032]及びその後継で定義されているEdDSAを利用した署名アルゴリズムを
  通知します。これは"PureEdDSA"であり、可変の"prehash"ではないことに注意
  してください。

 Legacyアルゴリズム
  特にSHA1ハッシュを使ったRSASSA-PKCS1-v1_5やECDSAなど、既知の脆弱性が知
  られているため、推奨されなくなったアルゴリズムを通知します。 この値は、
  証明書の署名に利用されるだけであり(Section 4.4.2.2参照)、TLSハンドシェ
  イクメッセージの署名向けに定義されるものではありません。エンドポイント
  はこれらのアルゴリズムでネゴシエーションを行うべきではなく[SHOULD NOT]、
  後方互換性のためのみに利用が許されています。クライアントは、これらの値
  はリストの最も低い優先度として提供しなければなりません[MUST](SchemeList
  に他のすべてのアルゴリズムよりも後に入れます)。TLS 1.3サーバは有効な証
  明書チェインを生成できない場合、このパラメータの通知なしに、SHA-1証明書
  を提供してはなりません[MUST NOT](Section 4.4.2.2参照)。

自己証明書やトラストアンカーの証明書は認証のパスの始点となっているため、
それ自身を検証することができません([RFC5280]、Section 3.2を参照)。認証パ
スの始点である証明書は"signature_algorithms"拡張でサポートが伝えられてい
ない署名アルゴリズムでも使うことが可能です[MAY]。

TLS 1.2のこの拡張の定義はこれとは異なることに注意してください。TLS 1.3の
実装でTLS 1.2をネゴシエーションしようとする時は、[RFC5246]に要求されてい
るように振る舞わなければなりません[MUST]。特に下記のことに留意してくださ
い。

 - TLS 1.2のClientHelloはこの拡張を無視する可能性があります。

 - TLS 1.2では、この拡張はハッシュと署名のペアになります。ペアは2オクテッ
   トでエンコードされているため、SignatureSchemeの値はTLS 1.2のエンコーディ
   ングと同じように割り当てられています。一部のレガシーのペアは割り当てら
   れてはいません。これらのアルゴリズムはTLS 1.3では廃止されています。ど
   の実装においてもネゴシエーションや、提供を行ってはなりません[MUST NOT]。
   特に、MD5[SLOTH]、SHA-224、DSAは使用してはいけません[MUST NOT]。

 - ECDSAの署名スキームは、TLS 1.2ではECDSAハッシュと署名のペア担っています。
   しかし、古いセマンティクスは署名に用いる楕円曲線に制約を持っていません。
   TLS 1.2でネゴシエーションされている場合、実装は"supported_groups"拡張で
   通知されたどの曲線が利用されても受け付けるようにシなければなりません[MUST]。

 - 実装において、RSASSA-PSS(TLS 1.3では実装が必須)のサポートを通知された場
   合、TLS 1.2でネゴシエーションされたとしても、そのスキームを使用した署名
   を受け付けるようにしなければなりません[MUST]。TLS 1.2では、RSASSA-PSSは
   RSAの暗号スイートとして使われます。


4.2.4. Certificate Authorities
"certificate_authorities"拡張は、エンドポイントがサポートしている、あるいは
受信先のエンドポイントが証明書を選択するための指標として利用するための、証
明書の認証局を通知するために使用されます。

"certificate_authorities"拡張のボディはCertificateAuthoritiesExtension構造
体で構成されています。

    opaque DistinguishedName<1..2^16-1>;

    struct {
        DistinguishedName authorities<3..2^16-1>;
    } CertificateAuthoritiesExtension;

 authorities
  DERエンコード[X690]された、受付可能な認証局のDN[X501]のリストです。これら
  のDNはトラストアンカーか中間CA証明書のDNを指定します。つまり、このメッセー
  ジは望ましい既知のトラストアンカーを記載するために使用されます。

クライアントはClientHelloに"certificate_authorities"拡張を入れて送信すること
ができます[MAY]。サーバはCertificateRequestメッセージで送信することができま
す[MAY]。

サーバの"trusted_ca_keys"拡張は、[RFC6066]と同じ目的で利用しますが、少し複雑
なものとなっており、またTLS 1.3では利用されません(しかしながら、クライアント
が以前のバージョンのTLSを要求する場合は、クライアントのClientHelloメッセージ
に載る場合があります)。


4.2.4.1. OID Filters
"oid_filters"拡張は、サーバがクライアント証明書が必要な場合に、OIDと値のペア
を提供することができます。この拡張は、サーバによって提供された場合、ただ
CertificateRequestメッセージを送信しなければなりません。

    struct {
        opaque certificate_extension_oid<1..2^8-1>;
        opaque certificate_extension_values<0..2^16-1>;
    } OIDFilter;

    struct {
        OIDFilter filters<0..2^16-1>;
    } OIDFilterExtension;

 filters
  DERエンコード[X690]フォーマットの許可されている証明書拡張OID[RFC5280]のリ
  ストです。一部の証明書拡張OIDは複数の値をとります(つまり、Extended Key Usage
  です)。サーバが空ではないフィルタリストを通知した場合、クライアント証明書
  にはクライアントが認識した拡張OIDのすべてを応答に含めなければなりません[MUST]。
  クライアントによって認識された各拡張OIDのすべてがクライアント証明書に含ま
  れなければなりません[MUST](ただし証明書が他の値である可能性があります[MAY])。
  しかし、クライアントは認識できない拡張OIDについては無視し、スキップしなけ
  ればなりません[MUST]。クライアントが証明書拡張OIDによって要求されたOIDを
  無視し、要求を満たさない証明書を提供した場合、サーバ自身の裁量によって、
  クライアント認証無しで接続を継続するか、"unsupported_certificate"アラート
  でハンドシェイクを破棄するか選択できます[MAY]。

PKIX RFCは証明書拡張OIDの種類と対応する値を定義します。種類によって、ビット
単位による照会が必要ない場合があります。TLSの実装には、証明書拡張OIDを利用
した証明書の選択を、それぞれのPKIライブラリに依存した動作で行われることが
期待されています。

このドキュメントは、[RFC5280]に定義された2つの標準の証明書拡張による照会ル
ールを定義しています。

 - リクエスト内すべてのkey usageビットが、証明書のKey Usage拡張にある場合、
   Key Usage拡張が一致することになります。

 - 証明書のExtended Key Usage拡張は、リクエストの目的のOIDキーがすべて
   Extended Key Usageに見つかった場合でも一致したことになります。リクエス
   トに、anyExtendedKeyUsage OIDを使用してはいけません[MUST]。

他の仕では、別の証明書拡張の一致規則を定義している可能性があります。


4.2.5. ハンドシェイク後のクライアント認証
"post_handshake_auth"拡張は、クライアントがハンドシェイク後にSection 4.6.2
の認証処理を行いたいことを通知します。サーバは、クライアントが要求しない限
り、ハンドシェイク後にCertificateRequestを送信してはなりません[MUST]。サー
バはこの拡張を送信してはなりません[MUST NOT]。

"post_handshake_auth"拡張の"extension_data"フィールドは長さは0です。

4.2.6. Negotiated Groups
クライアントによって送信される、"supported_groups"拡張は、クライアントがサ
ポートしている鍵交換のグループ名が優先度が高い順に通知します。

注意:TLS 1.3以前のバージョンでは、この拡張は"elliptic_curves"拡張と呼ばれ
ており楕円曲線のグループのみが含まれていました。詳細は[RFC4492]および
[RFC7919]を参照してください。また、この拡張はECDSAにおける曲線種類のネゴシ
エーションにも利用されていました。署名アルゴリズムについては、独立してネゴ
シエーションされるようになっています(Section 4.2.3参照)。

この拡張の"extension_data"フィールドは"NamedGroupList"の値です。

    enum {
        /* Elliptic Curve Groups (ECDHE) */
        secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
        x25519(0x001D), x448(0x001E),

        /* Finite Field Groups (DHE) */
        ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096 (0x0102),
        ffdhe6144(0x0103), ffdhe8192(0x0104),

        /* Reserved Code Points */
        ffdhe_private_use(0x01FC..0x01FF),
        ecdhe_private_use(0xFE00..0xFEFF),
        (0xFFFF)
    } NamedGroup;

    struct {
        NamedGroup named_group_list<2..2^16-1>;
    } NamedGroupList;

 Elliptic Curve Groups (ECDHE)
  FISP 186-4[DSS]や[RFC7748]に定義されている、名前付き曲線のサポートを通知
  します。0xFE00から0xFEFFはプライベート利用のための予約領域です。

 Finite Field Groups (DHE)
  [RFC7919]に定義の有限体グループのサポートを通知します。0x01FCから0x01FF
  はプライベート利用のための予約領域です。

named_group_listの要素はクライアントの優先度によって並べられています(先頭
が最優先)。

TLS 1.3では、サーバは"supported_groups"拡張をクライアントに送信することが
できます。クライアントは、ハンドシェイクの成立前に"supported_groups"で見つ
けた情報で動作してはなりませんが[MUST NOT]、ハンドシェイクの成立から学習し
た情報で以降のコネクションの"key_share"拡張に使うグループを変更することが
できます。サーバが"key_share"拡張にある一つのグループをサポートしているが、
ClientHelloでまだ受け付けられていない場合、クライアントの設定を更新するた
め、"supported_groups"を送信するべきです[SHOULD]。この場合、クライアントの
サポート状況に関係なく、サーバがサポートしているすべてのグループを拡張に含
めるべきです[SHOULD]。


4.2.7. Key Share
"key_share"拡張はエンドポイントの暗号パラメータを格納したものです。

クライアントは空のclient_shareを送信し、追加のラウンドトリップコストを払い、
サーバのグループ選択の要求を見ることがあります。(Section 4.1.4参照)

    struct {
        NamedGroup group;
        opaque key_exchange<1..2^16-1>;
    } KeyShareEntry;

 group
  鍵交換方式の名前グループです。有限体のDiffie-Hellman[DH]パラメータは
  Section 4.2.7.1に、楕円曲線のDiffie-Hellmanは Section 4.2.7.2に記載してい
  ます。

 key_exchange
  鍵交換の情報です。このフィールドの内容は、それぞれの方式によって決められ
  ています。

この拡張の"extension_data"フィールドは次の"KeyShare"を含んでいます。

    struct {
        select (Handshake.msg_type) {
            case client_hello:
                KeyShareEntry client_shares<0..2^16-1>;

            case hello_retry_request:
                NamedGroup selected_group;

            case server_hello:
                KeyShareEntry server_share;
        };
    } KeyShare;

 client_shares
  クライアントの優先度順に並んだ、要求したKeyShareEntryのリストです。このベ
  クトルは、クライアントがHelloRetryRequestを要求している場合、空になる可能
  性があります。各KeyShareEntryの値は、"supported_groups"拡張で要求されたグ
  ループと一致しなければならず[MUST]、同じ順番でなければなりません[MUST]。
  しかし、値は"supported_groups"拡張と完全に同じである必要はなく[MAY]、最も
  優先しているグループが省略される可能性があります[MAY]。このような状況では、
  最も優先するグループが新しく、サポート状況が十分でない場合、前世代の鍵が共
  有されることが発生し得ます。
  
 selected_group
  サーバがネゴシエーションを行いたいため、ClientHello/KeyShareで再試行を要求
  している、双方でサポートしているグループ。

 server_share
  クライアントのKeyShareEntryの内の、一つのKeyShareEntryの値。

クライアントはKeyShareEntryを複数要求することができ、各々は鍵交換のパラメー
タのセットです。具体的には、クライアントが共有を要求するいくつかの楕円曲線ま
たは複数のFFDHEグループになります。各KeyShareEntryのkey_exchangeの値は、独立
して生成されなければなりません[MUST]。クライアントは複数のKeyShareEntryの値で
同じグループを要求してはいけません[MUST NOT]。クライアントは自身の"supported_groups"
にないKeyShareEntryの値を提供してはいけません[MUST NOT]。また、サーバはこれら
のルールのチェックを行い、もし1つでも違反している場合は"illegal_parameter"ア
ラートによりハンドシェイクを破棄する可能性があります[MAY]。

この拡張をHelloRetryRequestで受信した時、クライアントは次の2つについて検証を
行わなければなりません[MUST]。
(1)selected_groupフィールドが提供したClientHelloの"supported_groups"拡張に含
   まれていたものであること。
(2)selected_groupフィールドが提供したClientHelloの"key_share"拡張に含まれてい
   ないものであること。
もし、いずれかの検証に失敗した場合は、クライアントは"illegal_parameter"アラー
トによりハンドシェイクを破棄しなければなりません[MUST]。つまり、新たなClientHello
を送信した時、クライアントは元の"key_share"拡張を、契機となったHelloRetryRequest
のselected_groupフィールドで通知された、新しいグループのKeyShareEntryに置き換
えなければなりません[MUST]。

(EC)DHE鍵を利用する場合、サーバはServerHelloで一つのKeyShareEntryを要求します。
この値はクライアントによって要求されたKeyShareEntryの内、サーバがネゴシエーショ
ンのために選択した値と同じグループでなければなりません[MUST]。サーバは、
"supported_groups"拡張で通知されていないKeyShareEntryを送信してはならず[MUST NOT]、
また、PskKeyExchangeModeの"psk_ke"を利用する時では、KeyShareEntryを送信してはな
りません[MUST NOT]。クライアントからHelloRetryRequestを受けた場合、クライアント
はServerHelloのNamedGroupで選択されたものがHelloRetryRequestと同じものであるか
検証しなければなりません[MUST]。もし検証に失敗した場合、クライアントは
"illegal_parameter"アラートによりハンドシェイクを破棄しなければなりません[MUST]。


4.2.7.1. Diffie-Hellmanパラメータ
クライアントおよびサーバのDiffie-Hellman[DH]パラメータは、KeyShare中のKeyShareEntry
構造体のkey_exchangeフィールドにopaqueの形式でエンコードされています。opaque値は
特定のグループ(グループの定義については[RFC7919]を参照)のDiffie-Hellmanの公開鍵
(Y = g^X mod p)がビックエンディアンかつ、左詰めでゼロパディングされた形式で格納
されています。

注意:Diffie-Hellmanグループは、公開鍵が同じ長さになるようにパディングされていま
     す。

ピアは互いの公開鍵Yが 1 < Y < p-1 の範囲であることを検査シなければなりません[MUST]。
このチェックは通信相手の振る舞いと、こちらのシステムを小さいサブグループに強制さ
せないことを保証するものです。	


4.2.7.2. ECDHEパラメータ
クライアントおよびサーバのECDHEパラメータはネットワークバイトオーダで、XとYの値を
バイナリで表します。これらは内部で長さを記述しておらず、各要素の長さは曲線のパラ
メータによって決定されます。P-256では、XおよびYは32オクテットの長さで、必要であれ
ば左詰めでゼロパディングされます。同じく、P-384は48オクテット、P-521は66オクテッ
トになります。

secp256r1、secp384r1、secp521r1の曲線では、ピアは互いの公開鍵Yが、楕円曲線上の座
標であることを検証しなければなりません[MUST]。適切な懸賞手順は[X962]のSection 4.3.7
あるいは[KEYAGREEMENT]のSection 5.6.2.6に定義されています。このプロセスは3つのス
テップからなります。
(1)Yが無限遠点ではないこと。
(2)Y=(x,y)の距離が正しいものであること。
(3)(x,y)が楕円曲線の解であること。
実装者は、これらの曲線が正しいサブグループに属していることの検証までは行う必要は
ありません。

X25519やX448では、公開鍵の値は[RFC7748]に定義されている関数の入力および出力のバイ
ト配列です。X25519は32バイト、X448は56バイトです。

注意:TLS 1.3以前では、座標フォーマットのネゴシエーションが行われていましたが、
     TLS 1.3ではこの機能は削除され、単一の座標フォーマットになります。


4.2.8. Pre-Shared Key Exchange Mode
PSKを利用する場合、クライアントは"psk_key_exchange_modes"拡張を送信しなければなり
ません[MUST]。この拡張の意味として、クライアントがこれらの方式のPSKのみをサポート
し、ClientHelloのPSKの要求とサーバがNewSessionTicketで提供するものの両方を制限する
事になります。

クライアントは、"pre_shared_key"拡張を要求する場合、"psk_key_exchange_modes"拡張を
提供しなければなりません[MUST]。クライアントが"psk_key_exchange_modes"拡張なしに
"pre_shared_key"拡張を要求した場合、サーバはハンドシェイクを破棄しなければなりませ
ん[MUST]。サーバはクライアントのリストにない鍵交換方式を選択してはいけません[MUST NOT]。
この拡張もPSKによるレジュームのりようを制限します。サーバは通知されている方式と互
換性のないチケットによるNewSessionTicketを送信すべきではありません[SHOULD NOT]。
しかし、もしサーバがそのような振る舞いを行ったとしても、クライアントへの影響はセッ
ションのレジュームが失敗するのみに留まります。

サーバは"psk_key_exchange_modes"拡張を送信してはなりません[MUST NOT]。

    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;

    struct {
        PskKeyExchangeMode ke_modes<1..255>;
    } PskKeyExchangeModes;

 psk_ke
  PSKのみによって鍵を確立する方式です。この方式ではサーバは"key_share"値を提供して
  はいけません[MUST NOT]。

 psk_dhe_ke
  (EC)DHEを用いたPSKにより鍵を確立する方式です。この方式ではクライアントおよびサー
  バはSection 4.2.7に記載の"key_share"値を提供しなければなりません[MUST]。


4.2.9. Early Data Indication
PSKが利用される時、クライアントは最初のメッセージ送信時にアプリケーションデータを送
信することができます。クライアントはこの機能を利用する場合、"early_data"拡張と共に
"pre_shared_key"も提供しなければなりません[MUST]。

この拡張の"extension_data"フィールドは"EarlyDataIndication"値を格納しています。

    struct {} Empty;

    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;
            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;

max_early_data_sizeについてはSection 4.6.1を参照してください。

0-RTTデータのパラメータ(対称暗号、ALPNプロトコル等)は、PSKでのネゴシエーションの確立
と同様です。early dataの暗号化に使用されるPSKは、クライアントの"pre_shared_key"拡張の
リストの最初のPSKでなければなりません[MUST]。

NewSessionTicketにより提供されたPSKでは、サーバは選択したPSKのID
(PskIdentity.obfuscated_ticket_ageを2^32でモジュロ演算した結果とticket_age_addとの差分
によって計算されるもの)の寿命が許容範囲内であることを検証しなければなりません[MUST]
(Section 8参照)。許容範囲内ではなかった場合、サーバは0-RTTを拒否し、ハンドシェイクを継
続するべきで[SHOULD]、ClientHelloが新しいものであると前提した、他の挙動を行うべきでは
ありません。

最初に送信される0-RTTメッセージは、他の送信のものと同じ暗号化されたコンテントタイプを
持っていますが、別の鍵によって暗号化されています。サーバのFinishメッセージを受信した
後、サーバがearly dataを受け付けている場合、鍵交換を通知するためにEndOfEarlyDataメッセ
ージが送信されます。このメッセージは0-RTTの鍵によって暗号化されています。

"early_data"拡張を受信したサーバは、次の3つから1つの振る舞いを行わなければなりません[MUST]。

 - 拡張を無視し、正規の1-RTTの応答を行う。サーバは受信したearly dataのレコードの復号を
   無視した時、正規の1-RTTハンドシェイクを完了するまで、レコードの復号失敗をmax_early_data_size
   までスキップすることができます。

 - クライアントに対して、別のClientHelloをHelloRetryRequestにより要求します。クライア
   ントはこのHelloRetryRequestに対するClientHelloに"early_data"拡張を含めてはいけませ
   ん[MUST]。サーバは"application_data"タイプの他のコンテントタイプのすべてのレコード
   (暗号化されて通知されます)をスキップすることで、early dataを無視します。

 - EncryptedExtensionsにこの拡張を返却し、early dataによる通信を行うことを通知します。
   サーバはearly dataメッセージを部分的に受け取ることはできません。サーバがearly data
   を受け入れるメッセージを生成して送信した時点で、early dataメッセージがすでに送信済
   みである可能性があります。

early dataを受け入れるためには、サーバはPSKの暗号スイートを受け付け、クライアントの
"pre_shared_key"拡張の要求を選択しなければなりません[MUST]。加えて、チケットが確立して
いる間に、次の値がネゴシエーションと矛盾がないことを検証しなければなりません[MUST]。

 - TLSバージョンと暗号スイート

 - もしある場合、選択されたALPNプロトコル[RFC7301]

さらに拡張が0-RTT間で定義されている必要があります[MUST]。

これらのチェックが失敗した場合、サーバは拡張を返してはならず[MUST NOT]、前述されている
の2つのメカニズムのどちらかによる最初のフライトデータをすべて破棄しなければなりません(
つまり1-RTTまたは2-RTTにフェイルバックします)。クライアントが0-RTTハンドシェイクを試み、
サーバが拒否した場合、サーバは通常0-RTTレコード保護鍵を持っておらず、最初の0-RTT以外の
メッセージを見つけるために、復号を試みます(1-RTTハンドシェイク鍵を使用するか、
HelloRetryRequestのケースでの平文のClientHelloを探します)

サーバが"early_data"拡張を受け入れることを選択した場合、early dataレコードのエラーハン
ドリングにおいて同じ挙動を行うことが要求されます。特に、サーバが"early_data"拡張後の
0-RTTレコードの復号に失敗した場合、Section 5.2にあるように、"bad_record_mac"アラートに
よりコネクションを終了しなければなりません[MUST]。

サーバが"early_data"拡張を拒否した場合、クライアントアプリケーションはハンドシェイクの
完了後にearly dataの再送を選択することができます[MAY]。自動的にearly dataを再送すると
コネクション状態が正しくない可能性があることに注意してください。例えば、early dataを使
った時と別のALPNプロトコルをネゴシエーションで選択している時、アプリケーションは異なる
メッセージを構築する必要があります。同じように、early dataとコネクションの状態により、
ハンドシェイクの完了後にエラーが送信される可能性があります。

TLSの実装は自動的にearly dataを再送するべきではありません[SHOULD NOT]。アプリケーション
自身により、再送すべきか決定します。TLSの実装は同じALPNプロトコルを選択したコネクション
出ない限り、自動的にearly dataを再送してはなりません[MUST NOT]。


4.2.10. Pre-Shared Key Extension
"pre_shared_key"拡張は、PSK鍵の確立のためのハンドシェイクに利用する事前共有鍵を通知するために使用されます。

この拡張の"extension_data"フィールドは"PreSharedKeyExtension"値を格納しています。

    struct {
        opaque identity<1..2^16-1>;
        uint32 obfuscated_ticket_age;
    } PskIdentity;

    opaque PskBinderEntry<32..255>;

    struct {
        select (Handshake.msg_type) {
            case client_hello:
                PskIdentity identities<7..2^16-1>;
                PskBinderEntry binders<33..2^16-1>;

            case server_hello:
                uint16 selected_identity;
        };

    } PreSharedKeyExtension;


 identity
  キーのラベルです。例として、Appendix B.3.4に定義されているチケットや、外部で確立した
  事前共有鍵のラベルになります。

 obfuscated_ticket_age
  難読化された鍵の寿命です。Section 4.2.10.1に、NewSessionTicketメッセージを通して同一
  性を確認するための、この値の形式について述べられています。外部で確立されたものについ
  ては、0が使われるべきで[SHOULD]、サーバは値を無視しなければなりません[MUST]。

 identities
  クライアントがサーバとのネゴシエーションで用いるIDのリストです。"early_data"拡張
  (Section 4.2.9参照)に付随して送信される場合、最初のIDが0-RTTデータに利用されます。

 binders
  "pre_shared_keys"拡張によって要求された各PSKのHMAC値のセットで、要求されたものと同じ
  順番で並んでいます。計算方法は以降に記述します。

 selected_identity
  クライアントのリストからサーバが選択したIDのインデックスです(0から開始されます)。

各PSKは単一のハッシュアルゴリズムに関連しています。チケットメカニズム(Section 4.6.1)に
よって確立されたPSKは、チケットが確立されたコネクションのKDFハッシュアルゴリズムです。
外部によって確立されたPSKは、ハッシュアルゴリズムをPSKが確立された時に設定するか、ハッ
シュアルゴリズムが定義されない場合は、デフォルトのSHA-256に設定されなければなりません[MUST]。
サーバは、選択したPSK(あれば)と暗号スイートに矛盾がないことを保証しなければなりません。

実装者の注意:PSK/cipherの暗号スイートのマッチング要求の実装で最も率直な方法は、暗号ス
イートを最初にネゴシエートし、互換性のないPSKを排除することです。どのような不明なPSK
も(つまり、PSKデータベースにない、または不明な鍵によって暗号化されている)、単純に無視
されるべきです[SHOULD]。受け付けられないPSKが見つかった場合、サーバは可能であれば非PSK
のハンドシェイクを行うべきです[SHOULD]。

PSK鍵の確立を受け付ける前に、サーバはbinder値との一致を検証しなければなりません[MUST]
(Section 4.2.10.2以降を参照)。この値がない、または有効ではない場合、サーバはハンドシェ
イクを破棄しなければなりません[MUST]。サーバは複数のbinderでの検証はすべきではありま
せん[SHOULD NOT]。むしろ、単一のPSKを選択し、PSKに合った単独のbinderを検証すべきです[SHOULD]。
PSK鍵の確立を受け付けた時、サーバは選択したIDを"pre_shared_key"拡張で通知します。

クライアントは、サーバのselected_identityが提供した範囲のものであること、サーバが選択
した暗号スイートに関連したPSKのハッシュが通知されていること、ClientHelloの
"psk_key_exchange_modes"で要求された場合、サーバの"key_share"拡張があること、を確認し
なければなりません[MUST]。これらの値に矛盾がある場合、クライアントは"illegal_parameter"
アラートによりハンドシェイクを破棄しなければなりません[MUST]。

サーバが"early_data"拡張を提供している場合、クライアントはサーバのselected_identityが
0であることを検証しなければなりません[MUST]。0以外の値であった場合、クライアントは
"illegal_parameter"アラートによりハンドシェイクを破棄しなければなりません[MUST]。

この拡張はClientHelloの最後尾になければなりません[MUST](これは後述にあるように、実装を
容易にするためのものです)。サーバは拡張の最後尾であることをチェックしなければならず[MUST]、
最後尾ではなかった場合、"illegal_parameter"アラートによりハンドシェイクを破棄しなけれ
ばなりません[MUST]。


4.2.10.1. Ticket Age
クライアントにおいて、チケットの寿命はNewSessionTicketメッセージを受信してからの時間
になります。クライアントは"ticket_lifetime"を超えたチケットを利用してはなりません[MUST NOT]。
PskIdentityの"obfuscated_ticket_age"フィールドは、ミリ秒の寿命にチケットに含まれた
"ticket_age_add"値を加算した形式の難読化されたチケットの寿命を格納しています。2^32の
モジュロ演算についてはSection 4.6.1を参照してください。この加算は観測者がチケット無し
にコネクションの再利用を行うことを妨害します。NewSessionTicketメッセージの
"ticket_lifetime"フィールドは秒単位ですが、"obfuscated_ticket_age"はミリ秒ということ
に注意してください。これは、チケットの寿命が1週間に制限されているため、ミリ秒でも32bit
で十分です。


4.2.10.2. PSK Binder
PSK binder値は、PSKが生成されたハンドシェイク(NewSessionTicketメッセージによる場合)と
それが利用されたハンドシェイク間と同様に、PSKと現在のハンドシェイク間に関連づいて形成
されます。binderリストの各エントリはClientHelloからPreSharedKeyExtension.identitiesフィ
ールドまでの部分をハッシュとしたHMACを計算したものです。これは、ClientHelloのすべてを
含んだものですが、binderリスト自身は含まれていません。メッセージの長さのフィールド(全
体長、拡張ブロック長、"pre_shared_key"拡張の長さ)はbinderがすべて存在するとして決定さ
れます。

PskBinderEntryはFinishメッセージ(Section 4.4.4)と同様の方法で計算されますが、binder_key
であるBaseKeyは、要求されたPSKに一致するキースケジュールにより導出されます(Section 7.1
参照)。

ハンドシェイクがHelloRetryRequestを含んでいる場合、初回のClientHelloとHelloRetryRequest
は新しいClientHelloの複写を含んでいます。例えば、クライアントがClientHello1を送信した
場合、このbinderは次のように計算されます。

    Transcript-Hash(ClientHello1[truncated])

サーバがHelloRetryRequestを応答し、クライアントがClientHello2を送信した場合、このbinder
は次のように計算されます。

    Transcript-Hash(ClientHello1,
                    HelloRetryRequest,
                    ClientHello2[truncated])

ClientHello1の全てが、他のハンドシェイクのハッシュ計算に含まれることになります。初回
フライトでは、ClientHello1[truncated]のハッシュが直接利用されますが、2回目のフライト
では、Section 4.4.1にあるように、ClientHello1が"handshake_hash"メッセージとして再演算
されます。


4.2.10.3. 処理順番
クライアントはサーバのFinishを受け取るまで、0-RTTデータの"stream"が許可されており、
ハンドシェイクの切れ目で、EndOfEarlyDataメッセージを送信します。デッドロックを避ける
ため、"early_data"を受け取った時は、サーバはクライアントのClientHelloを受信後、
クライアントからのEndOfEarlyDataを待つのではなく、即時にServerHelloを送信しなければ
なりません[MUST]。


4.3. サーバパラメータ
EncryptedExtensionsおよびCertificateRequestの2つのサーバからのメッセージは、ハンドシェ
イクの停止の情報を含んでいます。これらのメッセージは、server_handshake_traffic_secret
によって導出された鍵によって暗号化されています。


4.3.1. Encrypted Extensions
すべてのハンドシェイクにおいて、サーバはServerHelloメッセージの後からEncryptedExtensions
メッセージを送信しなければなりません[MUST]。これがserver_handshake_traffic_secretによ
って導出された鍵で暗号化された最初のメッセージになります。

EncryptedExtensionsメッセージは保護されている拡張を含んでいます。つまり、暗号文を確立
するためには必要ないものではありますが、個別の証明書とは関連付けられてはいないものです。
クライアントは受け取ったEncryptedExtensionsが禁止されている拡張でないことをチェックし
なければならず[MUST]、禁止されている拡張を見つけた場合、"illegal_parameter"アラートに
よりハンドシェイクを破棄しなければなりません。

EncryptedExtensionsメッセージの構造:

    struct {
        Extension extensions<0..2^16-1>;
    } EncryptedExtensions;

 extensions
  拡張のリスト。詳細はSection 4.2の表を参照してください。


4.3.2. Certificate Request
クライアントを認証しようとするサーバは、クライアントからの証明書を要求することができま
す[MAY]。このメッセージを送信する場合、EncryptedExtensionsの後に送信しなければなりませ
ん[MUST]。

CertificateRequestメッセージの構造:

    struct {
        opaque certificate_request_context<0..2^8-1>;
        Extension extensions<2..2^16-1>;
    } CertificateRequest;

 certificate_request_context
  証明書要求および、クライアントからのCertificateメッセージの応答を識別するための
  opaque配列形式のデータ。certificate_request_contextはコネクションのスコープ内でユニー
  クでなければなりません[MUST](クライアントのCertificateVerifyメッセージのリプレイ攻撃
  を防ぐためのものです)。このフィールドは、Section 4.6.2にあるハンドシェイク後の認証を
  行わない場合は長さが0になります[SHALL]。ハンドシェイク後の認証を要求している時、サー
  バは、攻撃者がクライアントのCertificateVerifyメッセージを事前に計算して算出したクライ
  アントの一時鍵を持つことを防止するため、クライアントが予測できないコンテキスト(つまり
  ランダムに生成したもの)を作るべきです[SHOULD]。

 extensions
  要求された証明書のパラメータを記載した拡張のセットです。"signature_algorithms"拡張は
  必ず記載しなければならず[MUST]、他の拡張はこのメッセージが定義される場合に選択的に含
  まれています。クライアントは解釈できない拡張については無視しなければなりません[MUST]。

以前のバージョンのTLSにおいて、CertificateRequestメッセージは、署名アルゴリズムのリスト
とサーバが受け付けるCA局を伝えるものでした。TLS 1.3では、前者は"signature_algorithms"拡
張によって送信されるようになっており、後者は"certificate_authorities"拡張(Section 4.2.4
参照)によって送信されます。

PSKで認証を行うサーバは、メインのハンドシェイクにおいてCertificateRequestメッセージを送
信してはならないため[MUST NOT]、クライアントが提供した"post_handshake_auth"拡張(Section
4.2.5参照)によるハンドシェイク後の認証でCertificateRequestメッセージを送信することがで
きます[MAY]。


4.4. 認証メッセージ
Section 2で論じたように、TLSは通常、認証・鍵の確認・ハンドシェイクの完了のための共通のメッ
セージセット(Certificate・CertificateVerify・Finish)を使用します(PreSharedKeyのbinderも
また同じように鍵の確認を行います)。これらの3つのメッセージは、いつもハンドシェイクの最後
のメッセージとして送信されます。CertificateおよびCertificateVerifyメッセージは後述で定義
されるように、特定の状況下でのみ送信されます。Finishedメッセージは必ず認証ブロックの最後
として送信されます。これらのメッセージは[sender]_handshake_traffic_secretから導出される
鍵で暗号化されています。

Authenticationメッセージの計算は、すべて一律に次の入力によって算出されます。

 - 証明書および署名に利用される鍵

 - 複写ハッシュに含まれているメッセージセットで構成されるハンドシェイクのコンテキスト

 - MAC鍵の計算に使用されるベース鍵

これらの入力で、次のメッセージが構成されます。

 Certificate
  認証に利用される証明書および、証明書チェインでサポートされている証明書。証明書に基づい
  たクライアント認証は0-RTTモードではないことに注意してください。

 CertificateVerify
  複写ハッシュ(ハンドシェイクコンテキスト、Certificate)によるシグネチャ。

 Finished
  ベース鍵により導出したMAC鍵を利用した、複写ハッシュ(ハンドシェイクコンテキスト、Certificate、
  CertificateVerify)によるMAC。

次の表は各シナリオにおけるハンドシェイクコンテキストとMAC Base Keyを定義したものです。


   +-----------+----------------------------+--------------------------+
   | Mode      | Handshake Context          | Base Key                 |
   +-----------+----------------------------+--------------------------+
   | Server    | ClientHello ... later of E | server_handshake_traffic |
   |           | ncryptedExtensions/Certifi | _secret                  |
   |           | cateRequest                |                          |
   |           |                            |                          |
   | Client    | ClientHello ... later of   | client_handshake_traffic |
   |           | server                     | _secret                  |
   |           | Finished/EndOfEarlyData    |                          |
   |           |                            |                          |
   | Post-     | ClientHello ... client     | client_application_traff |
   | Handshake | Finished +                 | ic_secret_N              |
   |           | CertificateRequest         |                          |
   +-----------+----------------------------+--------------------------+


4.4.1. 複写ハッシュ
TLSの多くの暗号演算では、複写ハッシュ(transcript hash)の使用しています。この値は、各ハン
ドシェイクメッセージ、ハンドシェイクメッセージヘッダ、ハンドシェイクメッセージタイプ、フィ
ールド長を連結したもの(レコードレイヤーのヘッダは含めません)からハッシュを計算したものです。
つまり、

    Transcript-Hash(M1, M2, ... MN) = Hash(M1 || M2 ... MN)

通常のルールの例外として、サーバがHelloRetryRequestに対するClientHelloを応答した時、
ClientHello1はHash(ClientHello1)を含んだ、"message_hash"タイプの特殊なハンドシェイクメッセ
ージに置き換わります。

    Transcript-Hash(ClientHello1, HelloRetryRequest, ... MN) =
        Hash(message_hash ||        // Handshake type
             00 00 Hash.length ||   // Handshake message length
             Hash(ClientHello1) ||  // Hash of ClientHello1
             HelloRetryRequest ... MN)

この構造の理由は、中間ハッシュの状態全体(Section 4.2.2参照)のエクスポートを要求するのではな
く、サーバがcookieにClientHello1のハッシュのみを入れたステートレスなHelloRetryRequestを行え
るようにするためです。

具体的に、複写ハッシュは毎回、ClientHelloから始まる次の送信したメッセージ(ClientHello、
HelloRetryRequest、server CertififateRequest、server Certificate、server Certificate、server
CertificateVerify、server Finished EndOyDarlyData、client Certificate、client CertificateVerify
client Finish)ハンドシェイクメッセージのシーケンスから計算されます。

一般的に実装はネゴシエーションハッシュに基づいた複写ハッシュを行いながら、複写を行うことが
できます。しかしながら、ハンドシェイク後の認証を行った場合は、ハンドシェイクの終わりまでの
メッセージのみとなることに注意してください。


4.4.2. Certificate
このメッセージはピアにエンドポイントの証明書チェインを送るものです。

サーバは鍵交換で認証に証明書を利用する方式の時は、Certificateメッセージを送信しなければなり
ません[MUST](このドキュメンにおいてPSKを除くすべての鍵交換方式がこの方式です)。

クライアントはサーバがCertificateRequestメッセージ(Section 4.3.2)によってクライアント認証を
要求してきた場合に限り、Certificateメッセージを送信しなければなりません[MUST]。サーバがクラ
イアント認証を要求したが合う証明書を所持していない場合、クライアントは証明書を含まないCertificate
メッセージを送信しなければなりません[MUST](つまり、"certificate_list"フィールド長が0ものに
なります)。

Certificateメッセージの構造:

    struct {
        select(certificate_type){
            case RawPublicKey:
              // From RFC 7250 ASN.1_subjectPublicKeyInfo
              opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

            case X509:
              opaque cert_data<1..2^24-1>;
        };
        Extension extensions<0..2^16-1>;
    } CertificateEntry;

    struct {
        opaque certificate_request_context<0..2^8-1>;
        CertificateEntry certificate_list<0..2^24-1>;
    } Certificate;

 certificate_request_context
  CertificateRequestに対する応答をこのメッセージで行う場合、Certificateメッセージの値は、
  certificate_request_contextになります。他の場合(サーバ認証のケースでは)、このフィールド
  は0になります[SHALL]。

 certificate_list
  CertificateEntry構造体のチェインです。各要素は、一つの証明書と拡張のセットが含まれていま
  す。

 extensions
  CertificateEnctryの拡張のセットです。"Extension"フォーマットはSection 4.2に定義されてい
  ます。有効な拡張は、OCSP Status拡張([RFC6066]および[RFC6961])とSignedCertificateTimestamps
  ([RFC6962])です。拡張は、初回ハンドシェイクにあるClientHello拡張に対応する、Certificate
  メッセージ内になければなりません[MUST]。拡張をチェイン全体に適用する場合、最初のCertificateEntry
  に含まれているべきです[SHOULD]。

一致する証明書タイプの拡張が使われていない("server_certificate_type"または"client_certificate_type")、
またはX.509形式の証明書でネゴシエーションされた場合、各CertificateEntryはX.509証明書が格納
されます。送信者の証明書はリストの最初のCertificateEntryで来なければなりません[MUST]。続く
各証明書は一つ前のものを直接証明するものであるべきです[SHOULD]。これは、証明書の検証は各ト
ラストアンカーが独立して配信されて行うことが要求されているため、サポートしているピアから提
供された証明書が省略された証明書であるとわかっている場合、特定のトラストアンカーの証明書は
チェインから省略される場合があります[MAY]。

注意:TLS 1.3以前では、"certificate_list"の順序は直前の証明書を証明することが要求されていま
した。しかし、一部の実装では順序を入れ替えることもありました。サーバは過渡的な移行のために
現在のものと推奨されないものの両方を送信することもありますが、この他の場合は単純な設定の誤
りです。互換性を高めるため、すべての実装はチェインとは関係ない証明書の処理や、どのTLSバー
ジョンの順序のものでも扱えるようにすべきです[SHOULD]。ただし、エンドエンティティ証明書だけ
はチェインの最初になければなりません[MUST]。

RawPublicKeyタイプの証明書がネゴシエーションされた場合、certificate_listは[RFC7250]のSection 3
に定義されている、ASN1_subjectPublicKeyInfoを持つCertificateEntyを一つのみしか含んではなり
ません[MUST]。

[RFC6091]のOpenPGPタイプの証明書はTLS 1.3では使用してはなりません[MUST NOT]。

サーバのcertificate_listは必ず空ではないものでなければなりません[MUST]。クライアントは、サ
ーバの認証要求に対する応答の証明書について、適合する証明書を所持していない場合は、空の
certificate_listを送信します。


4.4.2.1. OCSP Status および SCT Extensions
[RFC6066]および[RFC6961]はサーバがOCSP応答をクライアントとネゴシエーションするための拡張を
提供しています。TLS 1.2およびそれ以前では、サーバはこの拡張の対応の通知に空の拡張を応答し、
OCSP情報はCertificateStatusメッセージで伝えていました。TLS 1.3では、サーバのOCSP情報は、関
連する証明書を含んだCertificateEntryの拡張によって伝えます。具体的に、サーバの"status_request"
拡張のボディ部は[RFC6960]の定義として解釈される、[RFC6066]で定義のCertificateStatus構造体
でなければなりません[MUST]。

同様に、[RFC6962]はTLS 1.2以前でサーバがServerHelloの拡張として、Signed Certificate Timestamp(SCT)
を送信するメカニズムを提供しています。TLS 1.3では、サーバのSCT情報はCertificateEntry拡張で
伝えられます。


4.4.2.2. サーバ証明書の選択
次の規則によって、サーバから証明書が送信されます。

 - 証明書のタイプは、明示的に折衝が行われない限り([RFC7250]によるもの)、X.509v3 [RFC5280]
   でなければなりません[MUST]。

 - サーバのエンドエンティティ証明書の公開鍵(および関連する制限)は、選択された認証アルゴリ
   ズムに合うものでなければなりません[MUST](現状は、RSA、ECDSAまたはEdDSA)。

 - 証明書は、クライアントの"sigunature_algorithms"拡張で通知された署名方式で署名された鍵
   (つまり、デジタル署名ビットはKey Usage拡張がある場合、設定されなければなりません)を受
   け付けなければなりません。

 - "server_name"および"certificate_authorities"拡張[RFC6066]は証明書の選択に利用されます。
   サーバが"server_name"拡張を要求する場合があるため、クライアントは可能であれば、この拡
   張を送信すべきです[SHOULD]。

サーバによって提供されたすべて証明書は、証明書チェインを提供できる場合、クライアントが提
供した"signature_algorithms"拡張にある署名アルゴリズムによって署名されていなければなりま
せん[MUST](Section 4.2.3参照)。自己証明書あるいは、信頼するトラストアンカーの証明書はチェ
インの一部として認証されず、どのアルゴリズムでも署名されている可能性があります。

サーバが通知したサポートしているアルゴリズムのみの証明書チェインを提供できない場合、クラ
イアントがサポートしているか不明な証明アルゴリズムを含んでいるかもしれない証明書チェイン
をクライアントへ送信し、ハンドシェイクを継続すべきです[SHOULD]。このフォールバックチェイ
ンでは、通常SHA-1ハッシュアルゴリズムを含めるべきではありませんが[SHOULD NOT]、
"signature_algorithms"拡張によってクライアントから許可されている場合は行ってもよく[MAY]、
それ以外は行ってはなりません[MUST]。

クライアントは、提供された証明書のチェインを構築できない場合やハンドシェイクを破棄するこ
とを決めた場合は、証明書に関連したアラート(デフォルトでは、"unsupported_certificate";
Section 6.2等を参照)によってハンドシェイクを破棄しなければなりません。

サーバが複数の証明書を持っている場合、上記の基準で一つの証明書を選択します(他の基準とし
ては、TCPレイヤーのエンドポイントのローカル設定があります)


4.4.2.3. クライアント証明書の選択
次の規則によって、クライアントから証明書が送信されます。

 - 証明書のタイプは、明示的に折衝が行われない限り([RFC7250]によるもの)、X.509v3 [RFC5280]
   でなければなりません[MUST]。

 - CertificateRequestメッセージに"certificate_authorities"拡張がある場合、証明書チェイン
   の少なくとも一つの証明書は、CAリストの内のいずれかから発行されたものであるべきです[SHOULD]。

 - Section 4.3.2にあるように、証明書は受付可能な署名アルゴリズムで署名されなければなりませ
   ん[MUST]。証明書の署名アルゴリズムに関する規制の緩和は、前のバージョンのTLSに見られるも
   ののため注意してください。

 - 空ではない"oid_filters"拡張を含むCertificateRequestメッセージの場合、エンドエンティティ
   証明書はSection 4.2.4.1にあるように、クライアントによって認識される拡張OIDと一致しなけ
   ればなりません[MUST]。

サーバ証明書では、現在のTLSでは使えないアルゴリズムの組み合わせが利用されるものがあること
に注意してください。


4.4.2.4. Certificateメッセージの受信
通常、証明書の検証処理についてはTLSのスコープ外です([RFC5280]参照)。このセクションでは、
TLS特有のものについて提供します。

サーバが空のCertificateメッセージを提供した場合、クライアントは"decode_error"アラートによ
りハンドシェイクを破棄しなければなりません[MUST]。

クライアントが証明書を送信してこない場合、サーバはクライアント認証なしにハンドシェイクを継
続するか、"certificate_require"アラートによりハンドシェイクを破棄するかを選択します[MAY]。
証明書チェインが受け付けられない場合(つまり、信頼するCAに署名されたものでない場合))もまた、
サーバはハンドシェイクを継続するか(クライアントは認証されてないとされます)、ハンドシェイク
を破棄します。

MD5ハッシュの署名が利用された証明書を受信したどのエンドポイントも、"bad_certificate"アラー
トによりハンドシェイクを破棄しなければなりません[MUST]。SHA-1は廃止予定であり、SHA-1を使用
している証明書を受信したエンドポイントは、"bad_certificate"アラートによりハンドシェイクを
破棄することが推奨されます[RECOMMENDED]。明確に記述すると、エンドポイントが自己証明書ある
いはトラストアンカーの証明書の場合は、受け付けても構わないことを意味しています[MAY]。

すべてのエンドポイントは、SHA-256へ移行するか、相互運用を維持しつつ可能な限り早くSHA-1サポ
ートを廃止していくことが推奨されます[RECOMMENDED]。

証明書の鍵の署名アルゴリズムとは、異なる署名アルゴリズムで署名されている可能性があることに
注してください[MAY](例えば、ECDSA鍵で署名されたRSA鍵など)。


4.4.3. Certificate Verify
このメッセージは、証明書の秘密鍵が正しいものであることを明示的に証明するために利用されます。
CertificateVerifyメッセージは、それまでのハンドシェイクの整合性を提供します。サーバは証明
書の認証する際、このメッセージを送信しなければなりません[MUST]。クライアントは証明書の認証
する際はこのメッセージを送信しなければなりません[MUST](つまり、空ではないCertificateメッセ
ージの場合)。送信する時は、このメッセージはCertificateメッセージの直後になければならず、ま
たFinishedメッセージの直前になければなりません[MUST]。

Certificateメッセージの構造:

    struct {
        SignatureScheme algorithm;
        opaque signature<0..2^16-1>;
    } CertificateVerify;

algorithmフィールドは、特定の署名アルゴリズムが使用されます(フィールドの定義については
Section 4.2.3を参照)。署名はそのアルゴリズムを使用したデジタル署名です。署名が行われるコン
テントはSection 4.4に記載されているハッシュです。

    Transcript-Hash(Handshake Context, Certificate)

デジタル署名は下記を連結したものから計算されます。

 - 64個の32(0x20)で構成された配列

 - コンテキストの配列

 - セパレータとする一つの0バイト

 - 署名されたコンテント

この構造は前TLSバージョンのServerKeyExchangeフォーマットの32バイトプレフィックス
(ClientHello.random)選択攻撃による署名メッセージを得る攻撃を防御する意図があります。初期の
64バイトパディングはサーバにコントロールされたServerHello.randomのプレフィクスをクリアしま
す。

サーバ署名のコンテキストの配列は"TLS 1.3, server CertificateVerify"であり、クライアントの
署名のコンテキストの配列は"TLS 1.3, client CertificateVerify"です。これは、別のコンテキス
トでの署名を分離し、クロスプロトコルの潜在的な攻撃を防ぎます。

例えば、複写ハッシュが32バイトの01である場合(この長さはSHA-256の場合に生成されるものです)
デジタル署名されるサーバのCertificateVerifyのコンテントは、次のようになります。

    2020202020202020202020202020202020202020202020202020202020202020
    2020202020202020202020202020202020202020202020202020202020202020
    544c5320312e332c207365727665722043657274696669636174655665726966
    79
    00
    0101010101010101010101010101010101010101010101010101010101010101

サーバ側では、CertificateVerifyメッセージのsignatureフィールドの計算の入力は、次のものです。

 - 署名されたコンテント

 - 送信した証明書の署名の秘密鍵

サーバからCertificateVerifyメッセージが送信された場合、署名アルゴリズムはサポートされてな
いアルゴリズムの証明書チェインしか有効なものがない以外は、クライアントの"signature_algorithms"
拡張で提供された内の一つのものでなければなりません[MUST](Section 4.2.3参照)。

クライアントによってCertificateVerifyメッセージが送信された場合、署名アルゴリズムはCertificateRequest
メッセージの"signature_algorithms"拡張のsupported_signature_algorithmsフィールドにある内の
一つのものを使用しなければなりません[MUST]。

加えて、署名アルゴリズムはサーバのエンドエンティティ証明書の鍵と合うものでなければなりませ
ん[MUST]。RSA署名は"signature_algorithms"にRSASSA-PKCS1-v1_5のアルゴリズムのあるなしに関わ
らず、RSASSA-PSSアルゴリズムで利用しなければなりません[MUST]。SHA-1アルゴリズムは、
CertificateVerifyメッセージの署名として使ってはなりません[MUST NOT]。この仕様において、す
べてのSHA-1署名アルゴリズムは、レガシーの証明書として定義され、CertificateVerifyの署名とし
ては有効なものではありません。

CertificateVerifyメッセージの受信者は、signatureフィールドを検証しなければなりません[MUST]。
検証に利用する入力は、次のものになります。

 - 署名されたコンテント

 - 関連するCertificateメッセージのエンドエンティティ証明書の公開鍵

 - 受信したCertificateVerifyメッセージのsignatureフィールドのデジタル署名

検証が失敗した場合、受信者は"decrypt_error"アラートによりハンドシェイクを破棄しなければな
りません[MUST]。


続く

